<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="description" content="Crime Festival 2025 - Admin Management Panel">
    <title>Admin Panel - TEK Management</title>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, doc, setDoc, getDoc, getDocs, collection, deleteDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        const firebaseConfig = {
          apiKey: "AIzaSyA_9_40aa_wO_19g-1bIrSB6742aMOPwjo",
          authDomain: "crime-festival-2025.firebaseapp.com",
          projectId: "crime-festival-2025",
          storageBucket: "crime-festival-2025.firebasestorage.app",
          messagingSenderId: "663770004335",
          appId: "1:663770004335:web:e42dbd983ab9b5277bc69a"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        window.firebaseDB = db;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseGetDoc = getDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseCollection = collection;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseOnSnapshot = onSnapshot;
        console.log("✅ Firebase connected!");
    </script>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary-gradient: linear-gradient(135deg, #ff6b00 0%, #ff8800 100%);
    --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    --primary-color: #ff6b00;
    --primary-light: #ff8800;
    --success-color: #28a745;
    --danger-color: #dc3545;
    --info-color: #17a2b8;
    --secondary-color: #6c757d;
    --text-dark: #1a1a2e;
    --text-medium: #333;
    --text-light: #666;
    --text-lighter: #999;
    --border-color: #ddd;
    --border-light: #dee2e6;
    --bg-light: #f8f9fa;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.1);
    --shadow-md: 0 4px 15px rgba(0,0,0,0.15);
    --shadow-lg: 0 10px 40px rgba(0,0,0,0.3);
    --shadow-xl: 0 20px 60px rgba(0,0,0,0.5);
    --radius-sm: 5px;
    --radius-md: 8px;
    --radius-lg: 10px;
    --radius-xl: 12px;
    --transition: all 0.2s ease;
    --min-touch-target: 44px;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: var(--bg-gradient);
    min-height: 100vh;
    padding: clamp(10px, 3vw, 20px);
    overflow-x: hidden;
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    width: 100%;
}

.section {
    background: white;
    border-radius: var(--radius-xl);
    padding: clamp(15px, 4vw, 30px);
    margin-bottom: clamp(15px, 3vw, 20px);
    box-shadow: var(--shadow-lg);
}

.header {
    background: var(--primary-gradient);
    padding: clamp(15px, 4vw, 30px);
    border-radius: var(--radius-xl);
    text-align: center;
    margin-bottom: clamp(15px, 3vw, 20px);
    box-shadow: var(--shadow-lg);
}

.header h1 {
    color: white;
    font-size: clamp(18px, 5vw, 32px);
    margin-bottom: 8px;
    font-weight: 700;
    letter-spacing: -0.5px;
}

.header p {
    color: rgba(255,255,255,0.95);
    font-size: clamp(12px, 3vw, 16px);
    font-weight: 500;
}

.section h2 {
    color: var(--text-dark);
    font-size: clamp(18px, 4vw, 24px);
    margin-bottom: 15px;
    padding-bottom: 12px;
    border-bottom: 3px solid var(--primary-color);
    font-weight: 700;
}

.section h3 {
    color: var(--text-medium);
    font-size: clamp(16px, 3.5vw, 20px);
    margin: clamp(15px, 3vw, 20px) 0 10px;
    font-weight: 600;
}

.team-input {
    display: flex;
    flex-direction: column;
    gap: clamp(8px, 2vw, 12px);
    margin-bottom: 15px;
}

.team-input input,
.sort-controls select {
    width: 100%;
    padding: clamp(12px, 3vw, 16px);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    font-size: clamp(14px, 3vw, 16px);
    transition: var(--transition);
    min-height: var(--min-touch-target);
}

.team-input input:focus,
.sort-controls select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 107, 0, 0.1);
}

.btn {
    padding: clamp(12px, 3vw, 16px) clamp(16px, 4vw, 24px);
    border: none;
    border-radius: var(--radius-md);
    font-size: clamp(14px, 3vw, 15px);
    font-weight: 700;
    cursor: pointer;
    transition: var(--transition);
    width: 100%;
    min-height: var(--min-touch-target);
    text-align: center;
    display: inline-block;
    line-height: 1.4;
}

.btn:hover {
    transform: translateY(-2px);
}

.btn:active {
    transform: translateY(0);
}

.btn-primary {
    background: var(--primary-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(255,107,0,0.3);
}

.btn-primary:hover {
    box-shadow: 0 6px 20px rgba(255,107,0,0.5);
}

.btn-danger {
    background: var(--danger-color);
    color: white;
    box-shadow: 0 4px 15px rgba(220,53,69,0.3);
}

.btn-success {
    background: var(--success-color);
    color: white;
    box-shadow: 0 4px 15px rgba(40,167,69,0.3);
}

.btn-secondary {
    background: var(--secondary-color);
    color: white;
}

.sort-controls {
    display: flex;
    flex-direction: column;
    gap: clamp(8px, 2vw, 10px);
    margin-bottom: 15px;
    align-items: stretch;
}

.sort-controls label {
    font-weight: 700;
    color: var(--text-medium);
    font-size: clamp(13px, 3vw, 14px);
}

.quick-actions {
    display: grid;
    grid-template-columns: 1fr;
    gap: clamp(8px, 2vw, 10px);
    margin-bottom: 15px;
}

.team-list {
    display: grid;
    grid-template-columns: 1fr;
    gap: clamp(12px, 3vw, 20px);
    margin-top: 15px;
}

.team-card {
    background: var(--bg-light);
    border: 2px solid var(--border-light);
    border-radius: var(--radius-lg);
    padding: clamp(12px, 3vw, 20px) clamp(10px, 2.5vw, 15px);
    transition: var(--transition);
    overflow: hidden;
}

.team-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-md);
}

.team-card.completed {
    border: 3px solid var(--success-color);
    background: linear-gradient(135deg, #f0fff4 0%, #d4edda 100%);
}

.team-card h3 {
    color: #0f3460;
    font-size: clamp(16px, 4vw, 20px);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    line-height: 1.3;
}

.tek-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(max(40px, 8vw), 1fr));
    gap: clamp(4px, 1.5vw, 6px);
    margin: 12px 0;
    width: 100%;
}

.tek-box {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-sm);
    font-size: clamp(10px, 2.5vw, 12px);
    font-weight: 700;
    border: 2px solid var(--border-color);
    background: white;
    min-height: var(--min-touch-target);
    min-width: var(--min-touch-target);
    padding: 4px;
    transition: var(--transition);
}

.tek-box.unlocked {
    background: #d4edda;
    border-color: var(--success-color);
    color: #155724;
}

.tek-box.clickable {
    cursor: pointer;
}

.tek-box.clickable:hover {
    transform: scale(1.1);
    box-shadow: var(--shadow-sm);
}

.tek-box.clickable:active {
    transform: scale(0.95);
}

.tek-box.disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.tek-box.unlocked.clickable:hover {
    background: #b8dacc;
    border-color: #1e7e34;
}

.tek-box:not(.unlocked).clickable:hover {
    background: #fff3cd;
    border-color: #ffc107;
}

.team-actions {
    display: grid;
    grid-template-columns: 1fr;
    gap: clamp(6px, 1.5vw, 8px);
    margin-top: 12px;
}

.team-actions .btn {
    font-size: clamp(13px, 3vw, 14px);
    padding: clamp(10px, 2.5vw, 14px) clamp(12px, 3vw, 16px);
}

.progress-bar {
    background: #e0e0e0;
    height: clamp(25px, 6vw, 30px);
    border-radius: var(--radius-xl);
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    background: var(--primary-gradient);
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 700;
    font-size: clamp(11px, 2.5vw, 13px);
    transition: width 0.3s ease;
    min-width: fit-content;
    padding: 0 8px;
}

.team-stats-grid {
    display: grid;
    grid-template-columns: auto auto 1fr;
    gap: 8px 12px;
    margin-bottom: 12px;
    font-size: clamp(12px, 2.5vw, 14px);
    align-items: baseline;
}

.team-stat-label {
    text-align: left;
    color: var(--text-light);
    white-space: nowrap;
}

.team-stat-colon {
    color: var(--text-light);
}

.team-stat-value {
    color: var(--text-medium);
}

.team-stat-value strong {
    font-weight: 700;
    color: var(--text-dark);
}

.completion-badge {
    background: var(--success-color);
    color: white;
    padding: 4px 8px;
    border-radius: var(--radius-sm);
    font-size: clamp(9px, 2vw, 10px);
    font-weight: 700;
    display: inline-block;
    margin-left: 5px;
}

.alert {
    padding: clamp(12px, 3vw, 15px) clamp(15px, 4vw, 20px);
    border-radius: var(--radius-md);
    margin-bottom: clamp(15px, 3vw, 20px);
    font-size: clamp(13px, 3vw, 14px);
    line-height: 1.5;
}

.alert-success {
    background: #d4edda;
    border: 1px solid #c3e6cb;
    color: #155724;
}

.alert-danger {
    background: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #721c24;
}

.alert-warning {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    color: #856404;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    overflow: auto;
    padding: clamp(10px, 3vw, 20px);
}

.modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: white;
    padding: clamp(15px, 4vw, 30px);
    border-radius: var(--radius-xl);
    max-width: 700px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: var(--shadow-xl);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 12px;
    border-bottom: 2px solid var(--primary-color);
}

.modal-header h2 {
    color: var(--text-dark);
    font-size: clamp(18px, 4vw, 24px);
    margin: 0;
    padding: 0;
    border: none;
}

.close-modal {
    font-size: clamp(24px, 6vw, 28px);
    cursor: pointer;
    color: var(--text-lighter);
    line-height: 1;
    padding: 5px 10px;
    transition: var(--transition);
    min-width: var(--min-touch-target);
    min-height: var(--min-touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-modal:hover {
    color: var(--text-medium);
}

.info-box {
    padding: clamp(12px, 3vw, 15px);
    border-radius: var(--radius-md);
    margin-bottom: clamp(15px, 3vw, 20px);
    font-size: clamp(12px, 2.5vw, 14px);
    line-height: 1.6;
}

.info-box-start {
    background: #e3f2fd;
    border-left: 3px solid #2196f3;
}

.info-box-complete {
    background: #d4edda;
    border-left: 3px solid var(--success-color);
}

.info-box strong {
    display: block;
    margin-bottom: 5px;
    font-weight: 700;
}

.timestamp-list {
    list-style: none;
    padding: 0;
}

.timestamp-item {
    padding: clamp(10px, 3vw, 12px);
    margin-bottom: 8px;
    background: var(--bg-light);
    border-left: 3px solid var(--primary-color);
    border-radius: var(--radius-sm);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
}

.timestamp-item .tek-label {
    font-weight: 700;
    color: #0f3460;
    font-size: clamp(13px, 3vw, 14px);
}

.timestamp-item .time {
    color: var(--text-light);
    font-size: clamp(12px, 2.5vw, 13px);
}

#firebaseStatus {
    position: fixed;
    bottom: clamp(15px, 3vw, 20px);
    right: clamp(15px, 3vw, 20px);
    background: var(--success-color);
    color: white;
    padding: clamp(10px, 3vw, 12px) clamp(15px, 4vw, 20px);
    border-radius: var(--radius-md);
    font-size: clamp(10px, 2.5vw, 11px);
    box-shadow: var(--shadow-md);
    display: none;
    max-width: min(250px, calc(100vw - 40px));
    line-height: 1.4;
    z-index: 9999;
    transition: var(--transition);
}

#firebaseStatus.syncing {
    background: var(--info-color);
    animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    font-weight: bold;
    margin-bottom: 10px;
    color: var(--text-dark);
}

.form-group textarea,
.form-group select {
    width: 100%;
    padding: 12px;
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    font-size: 14px;
    font-family: inherit;
    transition: var(--transition);
}

.form-group textarea {
    min-height: 120px;
    resize: vertical;
}

.form-group textarea:focus,
.form-group select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 107, 0, 0.1);
}

@media (min-width: 480px) {
    .team-input {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .team-input input {
        flex: 1;
        min-width: min(200px, 100%);
    }
    
    .btn {
        width: auto;
    }
    
    .quick-actions {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    
    .team-actions {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    
    .sort-controls {
        flex-direction: row;
        align-items: center;
    }
    
    .sort-controls select {
        width: auto;
        min-width: 200px;
    }
}

@media (min-width: 768px) {
    .tek-grid {
        grid-template-columns: repeat(11, minmax(0, 1fr));
        gap: clamp(5px, 1vw, 6px);
    }
    
    .tek-box {
        font-size: clamp(9px, 1vw, 11px);
        min-width: 38px;
        min-height: 38px;
        border-width: 1px;
        padding: 3px;
    }
    
    .team-list {
        grid-template-columns: repeat(auto-fill, minmax(min(420px, 100%), 1fr));
    }
}

@media (min-width: 1024px) {
    .team-list {
        grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
    }
}

@media (max-height: 600px) and (orientation: landscape) {
    .header {
        padding: clamp(10px, 2vw, 15px);
        margin-bottom: clamp(10px, 2vw, 15px);
    }
    
    .section {
        padding: clamp(12px, 3vw, 15px);
        margin-bottom: clamp(10px, 2vw, 15px);
    }
    
    .modal-content {
        max-height: 85vh;
    }
}

@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}
</style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🔒 CRIME MANAGEMENT</h1>
            <p>ADMIN PANEL</p>
        </div>
    
		<div class="section">
			<h2>➕ ΠΡΟΣΘΗΚΗ ΟΜΑΔΑΣ</h2>
			<div class="team-input">
				<input type="text" id="newTeamName" placeholder="ΟΝΟΜΑ" />
				<input type="text" id="newTeamPassword" placeholder="ΚΩΔΙΚΟΣ" />
				<input type="number" id="newTeamSize" placeholder="ΜΕΛΗ (1-10)" min="1" max="10" />
				<button class="btn btn-primary" onclick="addTeam()">ΠΡΟΣΘΗΚΗ ΟΜΑΔΑΣ</button>
			</div>

			<div style="margin-top: 15px; padding: 12px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
				<label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 14px;">
					<input type="checkbox" id="testingModeCheckbox" style="width: 20px; height: 20px; cursor: pointer;">
					<span style="font-weight: bold; color: #0d47a1;">🧪 ΛΕΙΤΟΥΡΓΙΑ ΔΟΚΙΜΩΝ (ΠΑΡΑΚΑΜΨΗ ΕΡΩΤΗΜΑΤΟΛΟΓΙΩΝ)</span>
				</label>
			</div>
			
			<div id="addTeamAlert"></div>
		</div>

<div class="section">
    <h2>📊 ΔΙΑΧΕΙΡΗΣΗ</h2>
    <div style="background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%); padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
        <label style="color: #000; font-weight: 700; margin-right: 10px;">ΛΕΙΤΟΥΡΓΙΑ:</label>
        <select id="adminMode" onchange="toggleAdminMode()" style="padding: 8px 15px; border-radius: 5px; border: 2px solid #000; font-weight: 700;">
            <option value="live">🎮 LIVE EVENT</option>
            <option value="testing">🧪 TESTING MODE</option>
        </select>
    </div>

    <h3 style="color: #0f3460; margin-top: 0;">🎮 LIVE EVENT</h3>
    <div class="quick-actions">
        <button class="btn" style="background: #ffc107; color: #000;" onclick="window.location.href='leaderboard.html'">🏆 LEADERBOARD (ADMIN)</button>
        <button class="btn" id="leaderboardToggleBtn" style="background: #dc3545; color: white;" onclick="toggleLeaderboard()">🔒 LOADING...</button>
        <button class="btn" style="background: #9c27b0; color: white;" onclick="openAlertModal()">📢 ΑΠΟΣΤΟΛΗ ΕΙΔΟΠΟΙΗΣΗΣ</button>
    </div>

    <h3 style="color: #0f3460;">💾 DATA MANAGEMENT</h3>
    <div class="quick-actions">
        <button class="btn" style="background: #17a2b8; color: white;" onclick="exportAllData()">💾 EXPORT DATA (GAME)</button>
        <button class="btn" style="background: #6c757d; color: white;" onclick="importData()">📥 IMPORT DATA (GAME)</button>
        <button class="btn" style="background: #059669; color: white;" onclick="exportSurveyDataToExcel()">📊 EXPORT SURVEYS (EXCEL)</button>
    </div>

	<h3 style="color: #0f3460;">🧪 TESTING & DEBUG</h3>
	<div class="quick-actions">
		<button class="btn btn-secondary" onclick="unlockAllForAll()">🔓 ΤΕΚΜΗΡΙΑ (ΟΛΑ)</button>
		<button class="btn" style="background: #17a2b8; color: white;" onclick="resetAllProgress()">🔄 RESET ΠΡΟΟΔΟΥ (ΟΛΕΣ)</button>
		<button class="btn" style="background: #6c757d; color: white;" onclick="clearAllSolutions()">📝 ΚΑΘΑΡΙΣΜΟΣ ΛΥΣΕΩΝ (ΟΛΕΣ)</button>
	</div>

    <h3 style="color: #dc3545;">⚠️ DANGER ZONE</h3>
    <div class="quick-actions" style="border: 2px solid #dc3545; padding: 15px; border-radius: 8px; background: rgba(220, 53, 69, 0.05);">
        <button class="btn" style="background: #e91e63; color: white;" onclick="deleteAllAlerts()">🗑️ ΔΙΑΓΡΑΦΗ ΕΙΔΟΠΟΙΗΣΕΩΝ (ΟΛΩΝ)</button>
        <button class="btn" style="background: #b91c1c; color: white;" onclick="deleteALLSurveysNuclear()">🗑️ ΔΙΑΓΡΑΦΗ ΕΡΩΤΗΜΑΤΟΛΟΓΙΩΝ (ΟΛΑ)</button>
        <button class="btn btn-danger" onclick="resetAll()">🗑️ ΔΙΑΓΡΑΦΗ ΟΜΑΔΩΝ (ΟΛΕΣ)</button>
    </div>
</div>

        <div class="section">
            <h2>👥 ΟΜΑΔΕΣ</h2>
            
            <div class="sort-controls">
                <label>ΤΑΞΙΝΟΜΗΣΗ:</label>
                <select id="sortOrder" onchange="refreshTeams()">
                    <option value="name">ΟΝΟΜΑ</option>
                    <option value="progress">ΠΡΟΟΔΟΣ</option>
                    <option value="completion">ΧΡΟΝΟΣ ΟΛΟΚΛΗΡΩΣΗΣ (ΤΑΧΥΤΕΡΟ)</option>
                    <option value="recent">ΠΙΟ ΠΡΟΣΦΑΤΟ</option>
                </select>
            </div>
            
            <div id="teamsContainer" class="team-list"></div>
        </div>
    </div>

    <div id="timestampModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTeamName">ΧΡΟΝΙΚΑ ΣΗΜΕΙΑ</h2>
                <span class="close-modal" onclick="closeModal()">&times;</span>
            </div>
            <div id="modalContent"></div>
        </div>
    </div>

    <div id="alertModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📢 ΑΠΟΣΤΟΛΗ ΕΙΔΟΠΟΙΗΣΗΣ</h2>
                <span class="close-modal" onclick="closeAlertModal()">&times;</span>
            </div>
            <div style="padding: 20px 0;">
                <div class="form-group">
                    <label>ΕΠΙΛΟΓΗ ΠΑΡΑΛΗΠΤΗ:</label>
                    <select id="alertTarget">
                        <option value="all">📢 ΟΛΕΣ ΟΙ ΟΜΑΔΕΣ</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>ΜΗΝΥΜΑ:</label>
                    <textarea 
                        id="alertMessage" 
                    ></textarea>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeAlertModal()">❌ ΑΚΥΡΩΣΗ</button>
                    <button class="btn" style="background: #9c27b0; color: white;" onclick="sendAlert()">📢 ΑΠΟΣΤΟΛΗ</button>
                </div>
            </div>
        </div>
    </div>

    <div id="firebaseStatus">
        ✅ Firebase Connected - Data Synced to Cloud
    </div>

<script>
let teamsData = {};
    const BASE_URL = window.location.origin + window.location.pathname.replace('admin.html', '');
    const TOTAL_TEKS = 11;
    
    function isFirebaseReady() {
        return typeof window.firebaseDB !== 'undefined';
    }

    function formatTime(ms) {
        if (!ms) return 'N/A';
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        
        const h = hours;
        const m = minutes % 60;
        const s = seconds % 60;
        
        if (h > 0) {
            return `${h}ω ${m}λ ${s}δ`;
        } else if (m > 0) {
            return `${m}λ ${s}δ`;
        } else {
            return `${s}δ`;
        }
    }

    function formatDateTime(isoString) {
        if (!isoString) return 'N/A';
        return new Date(isoString).toLocaleString('el-GR', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }

    async function saveTeamToFirebase(teamName, data) {
        if (!isFirebaseReady()) return false;
        try {
            await window.firebaseSetDoc(
                window.firebaseDoc(window.firebaseDB, 'teams', teamName),
                { ...data, lastUpdate: new Date().toISOString() }
            );
            console.log('✅ Firebase save successful');
            return true;
        } catch (error) {
            console.error('❌ Firebase save error:', error);

            const status = document.getElementById('firebaseStatus');
            if (status) {
                status.style.background = '#dc3545';
                status.innerHTML = '⚠️ Firebase Sync Failed - Using Local Storage';
                status.style.display = 'block';
            }
            
            return false;
        }
    }

    async function loadTeamFromFirebase(teamName) {
        if (!isFirebaseReady()) return null;
        try {
            const docRef = window.firebaseDoc(window.firebaseDB, 'teams', teamName);
            const docSnap = await window.firebaseGetDoc(docRef);
            return docSnap.exists() ? docSnap.data() : null;
        } catch (error) {
            console.error('Firebase load error:', error);
            return null;
        }
    }

    async function getAllTeamsFromFirebase() {
        if (!isFirebaseReady()) return [];
        try {
            const querySnapshot = await window.firebaseGetDocs(
                window.firebaseCollection(window.firebaseDB, 'teams')
            );
            const teams = [];
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                
                if (!data.deleted) {
                    teams.push({ name: doc.id, ...data });
                }
            });
            
            console.log(`🔥 Firebase returned ${teams.length} teams`);
            return teams;
        } catch (error) {
            console.error('Firebase load all error:', error);
            return [];
        }
    }

async function deleteAllAlerts() {
    if (!confirm('ΔΙΑΓΡΑΦΗ ΟΛΩΝ ΤΩΝ ΕΙΔΟΠΟΙΗΣΕΩΝ;')) {
        return;
    }
    
    if (!window.firebaseDB) {
        alert('❌ Firebase δεν είναι διαθέσιμο!');
        return;
    }
    
    try {
        const alertsRef = window.firebaseCollection(window.firebaseDB, 'alerts');
        const querySnapshot = await window.firebaseGetDocs(alertsRef);
        
        console.log(`🗑️ Found ${querySnapshot.size} alerts to delete`);
        
        if (querySnapshot.size === 0) {
            alert('✅ ΔΕΝ ΥΠΑΡΧΟΥΝ ΕΙΔΟΠΟΙΗΣΕΙΣ!');
            return;
        }
        
        const deletePromises = [];
        querySnapshot.forEach((doc) => {
            console.log(`🗑️ Deleting alert: ${doc.id}`);
            deletePromises.push(
                window.firebaseDeleteDoc(
                    window.firebaseDoc(window.firebaseDB, 'alerts', doc.id)
                )
            );
        });
        
        await Promise.all(deletePromises);
        alert(`✅ ΔΙΑΓΡΑΦΗΚΑΝ!`);
        console.log('✅ All alerts deleted successfully');
        
    } catch (error) {
        console.error('❌ Error deleting alerts:', error);
        alert(`❌ Σφάλμα`);
    }
}

async function deleteALLSurveysNuclear() {
    const confirm1 = confirm('⚠️ ΠΡΟΣΟΧΗ! ΘΑ ΔΙΑΓΡΑΨΕΙ ΟΛΑ ΤΑ ΕΡΩΤΗΜΑΤΟΛΟΓΙΑ (FAKE ΚΑΙ ΠΡΑΓΜΑΤΙΚΑ)!\n\nΣΙΓΟΥΡΑ;');
    if (!confirm1) return;
    
    const confirm2 = confirm('🚨 ΤΕΛΕΥΤΑΙΑ ΠΡΟΕΙΔΟΠΟΙΗΣΗ!\n\nΘΑ ΔΙΑΓΡΑΦΟΥΝ ΟΛΑ ΤΑ ΔΕΔΟΜΕΝΑ ΕΡΕΥΝΩΝ!\n\nΣΥΝΕΧΕΙΣ;');
    if (!confirm2) return;
    
    const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
    const querySnapshot = await window.firebaseGetDocs(surveysRef);
    
    const deletePromises = [];
    querySnapshot.forEach((doc) => {
        deletePromises.push(
            window.firebaseDeleteDoc(
                window.firebaseDoc(window.firebaseDB, 'surveys', doc.id)
            )
        );
    });
    
    await Promise.all(deletePromises);
    alert(`🗑️ ΔΙΑΓΡΑΦΗΚΑΝ ΟΛΑ ΤΑ ΕΡΩΤΗΜΑΤΟΛΟΓΙΑ!`);
    refreshTeams();
}

async function resetAllProgress() {
    const confirm1 = confirm('🔄 RESET ΠΡΟΟΔΟΣ ΓΙΑ ΟΛΕΣ ΤΙΣ ΟΜΑΔΕΣ;\n\nΘα διαγραφούν: τεκμήρια, timestamps, λύσεις\nΘα διατηρηθούν: ομάδες, κωδικοί, μεγέθη');
    if (!confirm1) return;
    
    if (!window.firebaseDB) {
        alert('❌ Firebase δεν είναι διαθέσιμο!');
        return;
    }
    
    try {
        const teams = await getAllTeams();
        let resetCount = 0;
        
        for (const team of teams) {
            const resetData = {
                password: team.password || null,
                teamSize: team.teamSize || null,
                testingMode: team.testingMode || false,
                unlocked: [],
                timestamps: {},
                evidenceTimestamps: {},
                startTime: null,
                completedAt: null,
                totalTimeMs: null,
                solution: null,
                lastUpdate: new Date().toISOString()
            };
            
            await saveTeam(team.name, resetData);
            resetCount++;
        }
        
        alert(`✅ ΠΡΟΟΔΟΣ RESET ΓΙΑ ${resetCount} ΟΜΑΔΕΣ!`);
        console.log(`✅ Reset progress for ${resetCount} teams`);
        refreshTeams();
        
    } catch (error) {
        console.error('❌ Error resetting progress:', error);
        alert(`❌ ΣΦΑΛΜΑ: ${error.message}`);
    }
}

async function clearAllSolutions() {
    const confirm1 = confirm('📝 ΚΑΘΑΡΙΣΜΟΣ ΛΥΣΕΩΝ ΓΙΑ ΟΛΕΣ ΤΙΣ ΟΜΑΔΕΣ?\n\nΘα διαγραφούν: υποβληθείσες λύσεις, χρόνοι ολοκλήρωσης\nΘα διατηρηθούν: ξεκλειδωμένα τεκμήρια, timestamps');
    if (!confirm1) return;
    
    if (!window.firebaseDB) {
        alert('❌ Firebase δεν είναι διαθέσιμο!');
        return;
    }
    
    try {
        const teams = await getAllTeams();
        let clearedCount = 0;
        
        for (const team of teams) {
            if (team.solution) {
                const updatedData = {
                    ...team,
                    testingMode: team.testingMode || false, 
                    solution: null,
                    completedAt: null,
                    totalTimeMs: null,
                    lastUpdate: new Date().toISOString()
                };
                
                await saveTeam(team.name, updatedData);
                clearedCount++;
            }
        }
        
        if (clearedCount === 0) {
            alert('ℹ️ ΔΕΝ ΥΠΑΡΧΟΥΝ ΛΥΣΕΙΣ ΓΙΑ ΚΑΘΑΡΙΣΜΟ');
        } else {
            alert(`✅ ΛΥΣΕΙΣ ΚΑΘΑΡΙΣΤΗΚΑΝ!`);
            console.log(`✅ Cleared solutions for ${clearedCount} teams`);
        }
        
        refreshTeams();
        
    } catch (error) {
        console.error('❌ Error clearing solutions:', error);
        alert(`❌ ΣΦΑΛΜΑ`);
    }
}

async function getAllTeams() {
        const allTeams = new Map();
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('unlocked_teks_')) {
                const teamName = key.replace('unlocked_teks_', '');
                const storedData = JSON.parse(localStorage.getItem(key));

                if (Array.isArray(storedData)) {
                    allTeams.set(teamName, { 
                        name: teamName, 
                        unlocked: storedData,
                        timestamps: {},
                        startTime: null,
                        completedAt: null,
                        totalTimeMs: null,
                        solution: null,
                        lastUpdate: null,
                        teamSize: null,
                        password: null,
                        evidenceTimestamps: {},
                        source: 'localStorage-legacy'
                    });
                } else {
                    allTeams.set(teamName, {
                        name: teamName,
                        password: storedData.password || null,
                        teamSize: storedData.teamSize || null,
                        unlocked: storedData.unlocked || [],
                        timestamps: storedData.timestamps || {},
                        evidenceTimestamps: storedData.evidenceTimestamps || {},
                        startTime: storedData.startTime || null,
                        completedAt: storedData.completedAt || null,
                        totalTimeMs: storedData.totalTimeMs || null,
                        solution: storedData.solution || null,
                        lastUpdate: storedData.lastUpdate || null,
                        source: 'localStorage'
                    });
                }
            }
        }

        if (isFirebaseReady()) {
            try {
                const firebaseTeams = await getAllTeamsFromFirebase();
                firebaseTeams.forEach(team => {
                    console.log(`📦 Processing team ${team.name} from Firebase`);
                    
                    const localTeam = allTeams.get(team.name);
                    
                    if (!localTeam) {
                        allTeams.set(team.name, {
                            name: team.name,
                            password: team.password || null,
                            teamSize: team.teamSize || null,
                            unlocked: team.unlocked || [],
                            timestamps: team.timestamps || {},
                            evidenceTimestamps: team.evidenceTimestamps || {},
                            startTime: team.startTime || null,
                            completedAt: team.completedAt || null,
                            totalTimeMs: team.totalTimeMs || null,
                            lastUpdate: team.lastUpdate || null,
                            solution: team.solution || null,
                            source: 'firebase'
                        });
                    } else {
                        const teamLastUpdate = team.lastUpdate || '0';
                        const localLastUpdate = localTeam.lastUpdate || '0';
                        const mergedTeamSize = team.teamSize || localTeam.teamSize || null;
                        const mergedPassword = team.password || localTeam.password || null;
                        
                        if (teamLastUpdate > localLastUpdate) {
                            console.log(`🔥 Firebase data is newer for ${team.name}`);
                            allTeams.set(team.name, {
                                name: team.name,
                                password: mergedPassword,
                                teamSize: mergedTeamSize,
                                unlocked: team.unlocked || [],
                                timestamps: team.timestamps || {},
                                evidenceTimestamps: team.evidenceTimestamps || {},
                                startTime: team.startTime || null,
                                completedAt: team.completedAt || null,
                                totalTimeMs: team.totalTimeMs || null,
                                lastUpdate: team.lastUpdate || null,
                                solution: team.solution || null,
                                source: 'firebase-newer'
                            });
						} else {
							console.log(`💾 localStorage data is current for ${team.name}, but preserving teamSize and testingMode`);
							localTeam.teamSize = mergedTeamSize;
							localTeam.password = mergedPassword;
							
							if (team.testingMode !== undefined && localTeam.testingMode === undefined) {
								localTeam.testingMode = team.testingMode;
							}
						}
                });
            } catch (error) {
                console.error('⚠️ Firebase load failed, using localStorage only:', error);
            }
        }
        
        const teams = Array.from(allTeams.values());
        console.log(`📊 Loaded ${teams.length} teams total`);
        return teams;
    }

async function getSurveyCompletionStatus(teamName) {
    if (!window.firebaseDB) {
        return { pre: 0, post: 0 };
    }
    
    try {
        const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
        const querySnapshot = await window.firebaseGetDocs(surveysRef);
        
        const preMembers = new Set();
        const postMembers = new Set();
        
        querySnapshot.forEach((doc) => {
            const docId = doc.id;
            if (docId.startsWith(`${teamName}_pre_`)) {
                const memberName = docId.replace(`${teamName}_pre_`, '');
                preMembers.add(memberName);
            } else if (docId.startsWith(`${teamName}_post_`)) {
                const memberName = docId.replace(`${teamName}_post_`, '');
                postMembers.add(memberName);
            }
        });
        
        return {
            pre: preMembers.size,
            post: postMembers.size
        };
    } catch (error) {
        console.error(`Error counting surveys for ${teamName}:`, error);
        return { pre: 0, post: 0 };
    }
}

async function saveTeam(teamName, data) {
	console.log('🔧 NEW CODE VERSION - saveTeam called');
    const existingTeam = teamsData[teamName];
    
    if (existingTeam && existingTeam.teamSize && !data.teamSize) {
        console.warn(`⚠️ teamSize missing in save, preserving existing value: ${existingTeam.teamSize}`);
        data.teamSize = existingTeam.teamSize;
    }
    
    if (existingTeam && existingTeam.testingMode !== undefined && data.testingMode === undefined) {
        console.warn(`⚠️ testingMode missing in save, preserving existing value: ${existingTeam.testingMode}`);
        data.testingMode = existingTeam.testingMode;
    }
    
    if (data.teamSize !== undefined && data.teamSize !== null) {
        data.teamSize = parseInt(data.teamSize);
        if (isNaN(data.teamSize) || data.teamSize < 1) {
            console.error(`Invalid teamSize for team ${teamName}:`, data.teamSize);
            alert('Error: Invalid team size!');
            return false;
        }
    }
    
    data.lastUpdate = new Date().toISOString();
    
    console.log(`💾 Saving team ${teamName} with data:`, {
        teamSize: data.teamSize,
        testingMode: data.testingMode,
        unlocked: data.unlocked?.length,
        hasPassword: !!data.password
    });
    
    localStorage.setItem(`unlocked_teks_${teamName}`, JSON.stringify(data));
    teamsData[teamName] = { name: teamName, ...data };
    
    const firebaseSuccess = await saveTeamToFirebase(teamName, data);
    
    if (!firebaseSuccess) {
        console.warn('⚠️ Continuing with localStorage only for team:', teamName);
    }
    
    if (firebaseSuccess && window.firebaseDB) {
        const docRef = window.firebaseDoc(window.firebaseDB, 'teams', teamName);
        const verify = await window.firebaseGetDoc(docRef);
        if (verify.exists()) {
            const saved = verify.data();
            console.log('✅ Verified team saved with teamSize:', saved.teamSize, 'testingMode:', saved.testingMode);
            if (!saved.teamSize || saved.teamSize < 1) {
                console.error('❌ teamSize not saved correctly!', saved);
            }
            if (saved.testingMode === undefined) {
                console.error('❌ testingMode not saved correctly!', saved);
            }
        }
    }
    
    refreshTeams();
    
    return true;
}

    async function exportAllData() {
        const teams = await getAllTeams();
        
        const dataStr = JSON.stringify({ 
            exportDate: new Date().toISOString(),
            teams: teams 
        }, null, 2);
        
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `crime-festival-backup-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        alert(`✅ Data Exported!`);
    }

    function importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            const text = await file.text();
            const data = JSON.parse(text);
            
            let imported = 0;
            for (const team of data.teams) {
                await saveTeam(team.name, team);
                imported++;
            }
            
            alert(`✅ Data Imported!`);
            refreshTeams();
        };
        
        input.click();
    }

async function addTeam() {
    const alertDiv = document.getElementById('addTeamAlert');
    const teamName = document.getElementById('newTeamName').value.trim().toLowerCase();
    const password = document.getElementById('newTeamPassword').value.trim();
    const teamSize = parseInt(document.getElementById('newTeamSize').value);
    const testingMode = document.getElementById('testingModeCheckbox').checked;
	
    console.log('🧪 Testing Mode Checkbox Value:', testingMode);
	
    
    if (!teamName) {
        alertDiv.innerHTML = '<div class="alert alert-danger">⚠️ Παρακαλώ εισάγετε όνομα ομάδας</div>';
        return;
    }
    if (!password) {
        alertDiv.innerHTML = '<div class="alert alert-danger">⚠️ Παρακαλώ εισάγετε κωδικό ομάδας</div>';
        return;
    }
    if (!teamSize || teamSize < 1 || teamSize > 10) {
        alertDiv.innerHTML = '<div class="alert alert-danger">⚠️ Παρακαλώ εισάγετε αριθμό μελών (1-10)</div>';
        return;
    }
    if (isFirebaseReady()) {
        const docRef = window.firebaseDoc(window.firebaseDB, 'teams', teamName);
        const docSnap = await window.firebaseGetDoc(docRef);
        if (docSnap.exists()) {
            alertDiv.innerHTML = '<div class="alert alert-warning">⚠️ Η ομάδα υπάρχει ήδη</div>';
            return;
        }
    }
    
    const teamData = {
        password: password,
        teamSize: teamSize,
        testingMode: testingMode,
        unlocked: [],
        timestamps: {},
        evidenceTimestamps: {},
        startTime: null,
        completedAt: null,
        totalTimeMs: null,
        solution: null,
        createdAt: new Date().toISOString()
    };
    
    console.log('📦 Creating team with data:', JSON.stringify(teamData, null, 2)); 
    
    await saveTeam(teamName, teamData);
    
    const modeText = testingMode ? ' (🧪 ΛΕΙΤΟΥΡΓΙΑ ΔΟΚΙΜΩΝ)' : '';
    alertDiv.innerHTML = `<div class="alert alert-success">✅ Η ομάδα "${teamName}" δημιουργήθηκε με κωδικό: <strong>${password}</strong> και <strong>${teamSize} μέλη</strong>${modeText}</div>`;
    
    document.getElementById('newTeamName').value = '';
    document.getElementById('newTeamPassword').value = '';
    document.getElementById('newTeamSize').value = '';
    document.getElementById('testingModeCheckbox').checked = false;
    
    setTimeout(() => { alertDiv.innerHTML = ''; }, 5000);
    refreshTeams();
}

let refreshTimeout = null;

function debouncedRefreshTeams() {
    if (refreshTimeout) clearTimeout(refreshTimeout);
    
    refreshTimeout = setTimeout(() => {
        refreshTeams();
        refreshTimeout = null;
    }, 300);
}

async function refreshTeams() {
    console.log('🔄 === REFRESH TEAMS START ===');
    showSyncStatus('🔄 Syncing data...', 'syncing');
    
    let teams = await getAllTeams();
    teamsData = {};
    teams.forEach(team => {
        teamsData[team.name] = team;
    });
    
    const container = document.getElementById('teamsContainer');
    const sortOrder = document.getElementById('sortOrder').value;

    console.log(`📊 Loaded ${teams.length} teams from Firebase/localStorage`);
    teams.forEach(t => console.log(`  - ${t.name}: ${t.unlocked.length} TEKs unlocked, data:`, t.unlocked));

if (teams.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;"></div>';
        if (window.timerInterval) {
            clearInterval(window.timerInterval);
        }
        
        showSyncStatus('✅ Data synced', 'success');
        console.log('🔄 === REFRESH TEAMS END ===');
        return;
    }
    
    teams = sortTeams(teams, sortOrder);
	const surveyCounts = new Map();
	for (const team of teams) {
		const counts = await getSurveyCompletionStatus(team.name);
		surveyCounts.set(team.name, counts);
	}
    container.innerHTML = '';    
    if (window.timerInterval) {
        clearInterval(window.timerInterval);
    }

window.timerInterval = setInterval(() => {
    document.querySelectorAll('.team-card').forEach(teamCard => {
        const teamName = teamCard.dataset.teamId;
        const team = teamsData[teamName];
        
        if (team && team.startTime && !team.completedAt && !team.solution) {
            const elapsed = Date.now() - new Date(team.startTime).getTime();
            const timerValue = teamCard.querySelector('.timer-value');
            
            if (timerValue) {
                timerValue.innerHTML = `<strong>${formatTime(elapsed)}</strong>`;
            }
        }
    });
}, 1000);
    
    const html = teams.map(team => {
        const progress = Math.round((team.unlocked.length / TOTAL_TEKS) * 100);
        const allEvidenceUnlocked = team.unlocked.length === TOTAL_TEKS;
        const solutionSubmitted = !!team.solution;
		const surveys = surveyCounts.get(team.name) || { pre: 0, post: 0 };
		const teamSize = team.teamSize || 0;
		
		let preStatusIcon = '❌';
		if (surveys.pre === teamSize && teamSize > 0) {
			preStatusIcon = '✅';
		} else if (surveys.pre > 0) {
			preStatusIcon = '⚠️';
		}
		
		let postStatusIcon = '❌';
		if (surveys.post === teamSize && teamSize > 0) {
			postStatusIcon = '✅';
		} else if (surveys.post > 0) {
			postStatusIcon = '⚠️';
		}
        
        let timingHtml = '';
        if (team.startTime) {
            const now = new Date();
            const startTime = new Date(team.startTime);
            
            if (solutionSubmitted && team.completedAt) {
                timingHtml = `
					<div class="team-stat-label">⏱️ ΧΡΟΝΟΣ ΟΛΟΚΛΗΡΩΣΗΣ</div>
					<div class="team-stat-colon">:</div>
					<div class="team-stat-value"><strong>${formatTime(team.totalTimeMs)}</strong></div>
                `;
            } else {
                const elapsed = now - startTime;
                timingHtml = `
					<div class="team-stat-label">⏱️ ΧΡΟΝΟΣ ΣΕ ΕΞΕΛΙΞΗ</div>
					<div class="team-stat-colon">:</div>
					<div class="team-stat-value timer-value"><strong>${formatTime(elapsed)}</strong></div>
                `;
            }
        }
  
        console.log(`🎨 Rendering team ${team.name} with unlocked:`, team.unlocked);
            
        return `
            <div class="team-card ${solutionSubmitted ? 'completed' : ''}" data-team-id="${team.name}">
				<h3>
					<span style="font-size: 24px;"></span> 
					${team.name.toUpperCase()}
					${team.testingMode ? '<span class="completion-badge" style="background: #2196f3;">🧪 ΔΟΚΙΜΗ</span>' : ''}
					${solutionSubmitted ? 
						'<span class="completion-badge">✅ ΟΛΟΚΛΗΡΩΘΗΚΕ</span>' : 
						(allEvidenceUnlocked ? '<span class="completion-badge" style="background: #17a2b8;">📦 ΠΛΗΡΗΣ ΣΥΛΛΟΓΗ</span>' : '')
					}
				</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${progress === 0 ? '100' : progress}%; ${progress === 0 ? 'background: #e0e0e0; color: #666;' : ''}">${progress}%</div>
                </div>
                <div class="team-stats-grid">
					<div class="team-stat-label">📊 ΞΕΚΛΕΙΔΩΜΕΝΑ ΣΤΟΙΧΕΙΑ</div>
					<div class="team-stat-colon">:</div>
					<div class="team-stat-value"><strong>${team.unlocked.length} / ${TOTAL_TEKS}</strong></div>

					<div class="team-stat-label">${preStatusIcon} ΠΡΟΚΑΤΑΡΚΤΙΚΗ ΕΡΕΥΝΑ</div>
					<div class="team-stat-colon">:</div>
					<div class="team-stat-value"><strong>${surveys.pre} / ${teamSize || 'N/A'} </strong></div>

					<div class="team-stat-label">${postStatusIcon} ΤΕΛΙΚΗ ΕΡΕΥΝΑ</div>
					<div class="team-stat-colon">:</div>
					<div class="team-stat-value"><strong>${surveys.post} / ${teamSize || 'N/A'} </strong></div>

					<div class="team-stat-label">🔑 ΚΩΔΙΚΟΣ ΟΜΑΔΑΣ</div>
					<div class="team-stat-colon">:</div>
					<div class="team-stat-value"><strong>${team.password || 'N/A'}</strong></div>
                    
                    ${timingHtml}
                </div>
				<div class="tek-grid">
					${Array.from({length: TOTAL_TEKS}, (_, i) => {
						const tekNum = (i + 1).toString();
						const isUnlocked = team.unlocked.includes(tekNum);
						const isLocked = !!team.solution;
						console.log(`  TEK ${tekNum}: unlocked=${isUnlocked}, array contains:`, team.unlocked);
						const onclickAttr = isLocked 
							? '' 
							: `toggleTek('${team.name}', ${i + 1})`;
						
						const titleText = isLocked 
							? 'Κλειδωμένο (λύση υποβλήθηκε)' 
							: (isUnlocked ? 'Κλικ για κλείδωμα' : 'Κλικ για ξεκλείδωμα');
						
						return `<div class="tek-box ${isUnlocked ? 'unlocked' : ''} ${isLocked ? 'disabled' : 'clickable'}" 
									 onclick="${onclickAttr}" 
									 title="${titleText}">${i + 1}</div>`;
					}).join('')}
				</div>
                <div class="team-actions">
                    <button class="btn btn-primary" onclick="viewTeam('${team.name}')">👀 ΠΡΟΒΟΛΗ</button>
                    <button class="btn" style="background: #17a2b8; color: white;" onclick="showTimestamps('${team.name}')">🕐 ΧΡΟΝΙΚΑ</button>
                    <button class="btn btn-success" onclick="unlockAll('${team.name}')">🔓 ΤΕΚΜΗΡΙΑ</button>
                    <button class="btn btn-secondary" onclick="resetTeam('${team.name}')">🔄 RESET</button>
                    <button class="btn btn-danger" onclick="deleteTeam('${team.name}')">🗑️ ΔΙΑΦΡΑΦΗ</button>
                </div>
            </div>
        `;
    }).join('');
    
container.innerHTML = html;
    showSyncStatus('✅ Data synced', 'success');
    console.log('🔄 === REFRESH TEAMS END ===');
}

    function sortTeams(teams, order) {
        switch(order) {
            case 'name':
                return teams.sort((a, b) => a.name.localeCompare(b.name));
            
            case 'progress':
                return teams.sort((a, b) => b.unlocked.length - a.unlocked.length);
            
            case 'completion':
                const completed = teams.filter(t => t.completedAt).sort((a, b) => a.totalTimeMs - b.totalTimeMs);
                const incomplete = teams.filter(t => !t.completedAt).sort((a, b) => b.unlocked.length - a.unlocked.length);
                return [...completed, ...incomplete];
            
            case 'recent':
                return teams.sort((a, b) => {
                    const aTime = a.lastUpdate || a.startTime || '0';
                    const bTime = b.lastUpdate || b.startTime || '0';
                    return bTime.localeCompare(aTime);
                });
            
            default:
                return teams;
        }
    }

async function showTimestamps(teamName) {
    const teams = await getAllTeams();
    const team = teams.find(t => t.name === teamName);
    
    if (!team) return;

    const modal = document.getElementById('timestampModal');
    const modalTeamName = document.getElementById('modalTeamName');
    const modalContent = document.getElementById('modalContent');

    modalTeamName.textContent = `ΧΡΟΝΙΚΑ ΣΗΜΕΙΑ - ${teamName.toUpperCase()}`;

    let html = '';
    if (team.startTime || team.completedAt) {
        html += '<div class="info-box info-box-start">';
        html += '<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; margin-bottom: 10px;">';
        
        if (team.startTime) {
            html += `<div><strong>🚀 ΕΝΑΡΞΗ:</strong> ${formatDateTime(team.startTime)}</div>`;
        }
        
        if (team.completedAt) {
            html += `<div><strong>🏁 ΟΛΟΚΛΗΡΩΣΗ:</strong> ${formatDateTime(team.completedAt)}</div>`;
        }
        
        html += '</div>';
        
        if (team.completedAt && team.totalTimeMs) {
            html += `<div><strong>⏱️ ΣΥΝΟΛΙΚΟΣ ΧΡΟΝΟΣ:</strong> ${formatTime(team.totalTimeMs)}</div>`;
        }
        
        html += '</div>';
    }

    if (team.timestamps && Object.keys(team.timestamps).length > 0) {
        html += '<h3 style="margin: 20px 0 10px 0;">ΞΕΚΛΕΙΔΩΜΕΝΑ ΤΕΚΜΗΡΙΑ:</h3>';
        html += '<ul class="timestamp-list">';
        const sortedTeks = Object.entries(team.timestamps)
            .sort((a, b) => new Date(a[1]) - new Date(b[1]));
        
        sortedTeks.forEach(([tek, timestamp]) => {
            html += `
                <li class="timestamp-item">
                    <span class="tek-label">ΤΕΚ #${tek.padStart(2, '0')}</span>
                    <span class="time">${formatDateTime(timestamp)}</span>
                </li>
            `;
        });
        
        html += '</ul>';
    } else {
        html += '<p style="color: #999; text-align: center; padding: 20px;">Δεν υπάρχουν χρονικά δεδομένα</p>';
    }

    modalContent.innerHTML = html;
    modal.classList.add('active');
}
    function closeModal() {
        const modal = document.getElementById('timestampModal');
        modal.classList.remove('active');
    }
    
    window.onclick = function(event) {
        const modal = document.getElementById('timestampModal');
        if (event.target === modal) {
            closeModal();
        }
    }

function viewTeam(teamName) {
    window.open(`${BASE_URL}index.html?team=${teamName}`, '_blank');
}

async function toggleTek(teamName, tekNumber) {
    console.log(`🎯 Toggle TEK ${tekNumber} for team ${teamName}`);
    
    const teams = await getAllTeams();
    const team = teams.find(t => t.name === teamName);
    
    if (!team) {
        alert('Ομάδα δεν βρέθηκε!');
        return;
    }
    
    if (team.solution) {
        alert('❌ Δεν μπορείτε να τροποποιήσετε τεκμήρια μετά την υποβολή λύσης!');
        return;
    }
    
    const tekStr = tekNumber.toString();
    const unlocked = [...(team.unlocked || [])];
    const timestamps = {...(team.timestamps || {})};
    
    if (unlocked.includes(tekStr)) {
        const index = unlocked.indexOf(tekStr);
        unlocked.splice(index, 1);
        delete timestamps[tekStr];
        console.log(`🔒 Locked TEK ${tekNumber} for team ${teamName}`);
    } else {
        unlocked.push(tekStr);
        timestamps[tekStr] = new Date().toISOString();
        console.log(`🔓 Unlocked TEK ${tekNumber} for team ${teamName}`);
    }
    
const updatedTeam = {
    password: team.password || null,
    teamSize: team.teamSize !== undefined ? team.teamSize : null,
    testingMode: team.testingMode !== undefined ? team.testingMode : false,
    unlocked: unlocked,
    timestamps: timestamps,
    evidenceTimestamps: team.evidenceTimestamps || {},
    startTime: team.startTime || new Date().toISOString(),
    completedAt: team.completedAt || null,
    totalTimeMs: team.totalTimeMs || null,
    solution: team.solution || null,
    lastUpdate: new Date().toISOString()
};
    
    console.log(`💾 Saving team ${teamName} with ${unlocked.length} TEKs`);
    await saveTeam(teamName, updatedTeam);
    await refreshTeams();
    
    console.log('✅ Toggle complete');
}

async function unlockAll(teamName) {
    if (confirm(`ΞΕΚΛΕΙΔΩΜΑ ΟΛΩΝ ΤΩΝ ΤΕΚΜΗΡΙΩΝ ΓΙΑ ΤΗΝ ΟΜΑΔΑ "${teamName}";`)) {
        console.log(`🔓 Unlocking all TEKs for team ${teamName}`);
        const teams = await getAllTeams();
        const team = teams.find(t => t.name === teamName);
        
        const allTeks = Array.from({length: TOTAL_TEKS}, (_, i) => (i + 1).toString());
        const now = new Date().toISOString();
        const timestamps = {...(team?.timestamps || {})};
        let earliestTime = team?.startTime || now;
        
        allTeks.forEach((tek, i) => {
            if (!timestamps[tek]) {
                timestamps[tek] = new Date(Date.now() + i * 100).toISOString();
            } else {
                const existingTime = new Date(timestamps[tek]);
                if (existingTime < new Date(earliestTime)) {
                    earliestTime = timestamps[tek];
                }
            }
        });
    
        const updatedTeam = {
            password: team?.password || null,
            teamSize: team?.teamSize !== undefined ? team.teamSize : null,
            testingMode: team?.testingMode !== undefined ? team.testingMode : false,
            unlocked: allTeks,
            timestamps: timestamps,
            evidenceTimestamps: team?.evidenceTimestamps || {},
            startTime: earliestTime,
            completedAt: team?.completedAt || null,
            totalTimeMs: team?.totalTimeMs || null,
            solution: team?.solution || null,
            lastUpdate: now
        };
    
        console.log(`💾 Saving unlock all for team ${teamName}`);
        await saveTeam(teamName, updatedTeam);
        await refreshTeams();
        
        console.log('✅ Unlock all complete');
    }
}

async function resetTeam(teamName) {
    if (confirm(`Reset πρόοδο για την ομάδα "${teamName}";`)) {
        const teams = await getAllTeams();
        const team = teams.find(t => t.name === teamName);
        
        await saveTeam(teamName, {
            password: team?.password || null,
            teamSize: team?.teamSize !== undefined ? team.teamSize : null,
            testingMode: team?.testingMode !== undefined ? team.testingMode : false,
            unlocked: [],
            timestamps: {},
            startTime: null,
            completedAt: null,
            totalTimeMs: null
        });
        refreshTeams();
    }
}

async function deleteTeam(teamName) {
    if (confirm(`ΔΙΑΓΡΑΦΗ ΟΜΑΔΑΣ "${teamName}" ΚΑΙ ΟΛΩΝ ΤΩΝ ΣΥΝΔΕΔΕΜΕΝΩΝ ΕΡΕΥΝΩΝ;`)) {
        console.log(`🗑️ Starting deletion for team: ${teamName}`);
        localStorage.removeItem(`unlocked_teks_${teamName}`);
        console.log(`✅ Deleted from localStorage`);
        
        if (isFirebaseReady()) {
            try {
                const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
                const querySnapshot = await window.firebaseGetDocs(surveysRef);
                
                const deletePromises = [];
                let surveyCount = 0;
                
                querySnapshot.forEach((doc) => {
                    const docId = doc.id;
                    if (docId.startsWith(`${teamName}_pre_`) || docId.startsWith(`${teamName}_post_`)) {
                        console.log(`🗑️ Queuing survey for deletion: ${docId}`);
                        surveyCount++;
                        deletePromises.push(
                            window.firebaseDeleteDoc(
                                window.firebaseDoc(window.firebaseDB, 'surveys', docId)
                            ).then(() => {
                                console.log(`✅ Deleted survey: ${docId}`);
                            }).catch(err => {
                                console.error(`❌ Failed to delete survey ${docId}:`, err);
                            })
                        );
                    }
                });
                
                console.log(`📊 Found ${surveyCount} surveys to delete`);
                if (deletePromises.length > 0) {
                    await Promise.all(deletePromises);
                    console.log(`✅ All surveys deleted successfully`);
                }
                
                await window.firebaseDeleteDoc(
                    window.firebaseDoc(window.firebaseDB, 'teams', teamName)
                );
                console.log(`✅ Deleted team document: ${teamName}`);                
            } catch (error) {
                console.error('❌ Firebase delete error:', error);
                alert(`⚠️ ΣΦΑΛΜΑ ΔΙΑΓΡΑΦΗΣ!`);
            }
        } else {
            console.warn('⚠️ Firebase not ready, only deleted from localStorage');
            alert('⚠️ Firebase δεν είναι διαθέσιμο. Διαγράφηκε μόνο τοπικά.');
        }
        
        refreshTeams();
    }
}

async function unlockAllForAll() {
    if (confirm('ΞΕΚΛΕΙΔΩΜΑ ΟΛΩΝ ΤΩΝ ΤΕΚΜΗΡΙΩΝ ΓΙΑ ΟΛΕΣ ΤΙΣ ΟΜΑΔΕΣ;')) {
        const teams = await getAllTeams();
        const allTeks = Array.from({length: TOTAL_TEKS}, (_, i) => (i + 1).toString());
        
        for (const team of teams) {
            const now = new Date().toISOString();
            const timestamps = {...(team.timestamps || {})};
            let earliestTime = team.startTime || now;
            
            allTeks.forEach((tek, i) => {
                if (!timestamps[tek]) {
                    timestamps[tek] = new Date(Date.now() + i * 100).toISOString();
                } else {
                    const existingTime = new Date(timestamps[tek]);
                    if (existingTime < new Date(earliestTime)) {
                        earliestTime = timestamps[tek];
                    }
                }
            });
            
await saveTeam(team.name, {
    password: team.password || null,
    teamSize: team.teamSize !== undefined ? team.teamSize : null,
    testingMode: team.testingMode !== undefined ? team.testingMode : false,
    unlocked: allTeks,
    timestamps: timestamps,
    startTime: earliestTime,
    completedAt: team.completedAt || null,
    totalTimeMs: team.totalTimeMs || null,
    solution: team.solution || null,
    evidenceTimestamps: team.evidenceTimestamps || {}
});
        }
        refreshTeams();
    }
}

async function resetAll() {
    if (confirm('ΔΙΑΓΡΑΦΗ ΟΛΩΝ ΤΩΝ ΟΜΑΔΩΝ ΚΑΙ ΕΡΕΥΝΩΝ;')) {
        const teams = await getAllTeams();
        console.log(`🗑️ Resetting ${teams.length} teams...`);
        for (const team of teams) {
            localStorage.removeItem(`unlocked_teks_${team.name}`);
        }
        console.log(`✅ Deleted all from localStorage`);
        
        if (isFirebaseReady()) {
            try {
                for (const team of teams) {
                    await window.firebaseDeleteDoc(
                        window.firebaseDoc(window.firebaseDB, 'teams', team.name)
                    );
                    console.log(`✅ Deleted team: ${team.name}`);
                }
                
                const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
                const querySnapshot = await window.firebaseGetDocs(surveysRef);
                
                const deletePromises = [];
                let surveyCount = 0;
                
                querySnapshot.forEach((doc) => {
                    console.log(`🗑️ Deleting survey: ${doc.id}`);
                    surveyCount++;
                    deletePromises.push(
                        window.firebaseDeleteDoc(
                            window.firebaseDoc(window.firebaseDB, 'surveys', doc.id)
                        )
                    );
                });
                
                await Promise.all(deletePromises);
                
                console.log(`✅ Deleted ${teams.length} teams and ${surveyCount} surveys`);
            } catch (error) {
                console.error('❌ Firebase delete error:', error);
                alert(`⚠️ ΣΦΑΛΜΑ: ${error.message}`);
            }
        }
        
        refreshTeams();
    }
}

async function checkLeaderboardStatus() {
    if (!window.firebaseDB) {
        console.warn('Firebase not ready');
        return false;
    }
    
    try {
        const docRef = window.firebaseDoc(window.firebaseDB, 'config', 'leaderboard');
        const docSnap = await window.firebaseGetDoc(docRef);
        
        if (docSnap.exists()) {
            return docSnap.data().unlocked || false;
        }
        return false;
    } catch (error) {
        console.error('Error checking leaderboard status:', error);
        return false;
    }
}

async function updateLeaderboardButton() {
    const isUnlocked = await checkLeaderboardStatus();
    const btn = document.getElementById('leaderboardToggleBtn');
    
    if (btn) {
        if (isUnlocked) {
            btn.innerHTML = '🔓 LEADERBOARD (TEAMS)';
            btn.style.background = '#28a745';
        } else {
            btn.innerHTML = '🔒 LEADERBOARD (TEAMS)';
            btn.style.background = '#dc3545';
        }
    }
}

async function toggleLeaderboard() {
    if (!window.firebaseDB) {
        alert('❌ Firebase δεν είναι διαθέσιμο!');
        return;
    }
    
    const currentStatus = await checkLeaderboardStatus();
    const newStatus = !currentStatus;
    
    try {
        const docRef = window.firebaseDoc(window.firebaseDB, 'config', 'leaderboard');
        await window.firebaseSetDoc(docRef, {
            unlocked: newStatus,
            lastModified: new Date().toISOString(),
            modifiedBy: 'admin'
        });
        
        await updateLeaderboardButton();
        
    } catch (error) {
        console.error('Error toggling leaderboard:', error);
        alert('❌ Σφάλμα! Δοκιμάστε ξανά.');
    }
}

async function exportSurveyDataToExcel() {
    if (!window.firebaseDB) {
        alert('❌ Firebase not available!');
        return;
    }

    try {
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 10000; text-align: center;';
        statusDiv.innerHTML = '<div style="font-size: 48px; margin-bottom: 20px;">⳿</div><h3>Exporting Survey Data...</h3><p>Please wait...</p>';
        document.body.appendChild(statusDiv);

        const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
        const querySnapshot = await window.firebaseGetDocs(surveysRef);
        
        console.log(`📊 Found ${querySnapshot.size} survey responses`);

        if (querySnapshot.size === 0) {
            alert('No survey data found!');
            document.body.removeChild(statusDiv);
            return;
        }

        const allResponses = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            allResponses.push({
                docId: doc.id,
                ...data
            });
        });

        allResponses.sort((a, b) => {
            if (a.teamCode !== b.teamCode) {
                return (a.teamCode || '').localeCompare(b.teamCode || '', 'el');
            }
            if (a.memberName !== b.memberName) {
                return (a.memberName || '').localeCompare(b.memberName || '', 'el');
            }
            const typeOrder = { 'pre': 1, 'post': 2 };
            return (typeOrder[a.surveyType] || 3) - (typeOrder[b.surveyType] || 3);
        });

        const SURVEY_COLUMN_ORDER = [
            'Document_ID',
            'Team_Code',
            'Member_Name',
            'Survey_Type',
            'Submitted_At',
            'Submission_Date',
            'Submission_Time',
            'group',
            'gender',
            'age',
            'education',
            'genai-used',
            'genai-duration',
            'genai-frequency',
            'genai-tools',
            'genai-tools-other',
            'genai-purposes',
            'genai-purposes-other',
            'prompt-ability',
            'trust-level',
            'verify-frequency',
            'biggest-challenge',
            'non-use-reason',
            'non-use-reason-other',
            'genai-awareness',
            'genai-concerns',
            'future-likelihood',
            'genai-motivators',
            'services-used',
            'genai-importance',
            'education-adequacy',
            'ai-attitude-1',
            'ai-attitude-2',
            'ai-attitude-3',
            'ai-attitude-4',
            'ai-attitude-5',
            'ai-attitude-6',
            'ai-attitude-7',
            'ai-attitude-8',
            'pu1',
            'pu2',
            'pu3',
            'pu4',
            'pu5',
            'pu6',
            'peu1',
            'peu2',
            'peu3',
            'peu4',
            'peu5',
            'peu6',
            'open-strategy',
            'open-difficulties',
            'open-learning'
        ];
        
        const processedData = allResponses.map(survey => {
            const flatData = {
                'Document_ID': survey.docId || '',
                'Team_Code': survey.teamCode || '',
                'Member_Name': survey.memberName || '',
                'Survey_Type': survey.surveyType || '',
                'Submitted_At': survey.submittedAt || '',
                'Submission_Date': survey.submittedAt ? new Date(survey.submittedAt).toLocaleDateString('el-GR') : '',
                'Submission_Time': survey.submittedAt ? new Date(survey.submittedAt).toLocaleTimeString('el-GR') : '',
            };
            
            if (survey.responses) {
                Object.keys(survey.responses).forEach(key => {
                    const value = survey.responses[key];
                    if (Array.isArray(value)) {
                        flatData[key] = value.join('; ');
                    } else {
                        flatData[key] = value;
                    }
                });
            }

            return flatData;
        });
        
        const allFieldsInData = new Set();
        processedData.forEach(row => {
            Object.keys(row).forEach(key => allFieldsInData.add(key));
        });
        
        const extraFields = Array.from(allFieldsInData)
            .filter(field => !SURVEY_COLUMN_ORDER.includes(field))
            .sort();

        const finalHeaders = [
            ...SURVEY_COLUMN_ORDER.filter(h => allFieldsInData.has(h)),
            ...extraFields
        ];
        
        const worksheetData = [
            finalHeaders,
            ...processedData.map(row => 
                finalHeaders.map(header => row[header] !== undefined ? row[header] : '')
            )
        ];
        
        const XLSX = await import('https://cdn.sheetjs.com/xlsx-0.20.1/package/xlsx.mjs');
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(worksheetData);
        
        const colWidths = finalHeaders.map(header => {
            const maxLength = Math.max(
                header.length,
                ...processedData.map(row => 
                    String(row[header] || '').length
                ).slice(0, 100)
            );
            return { wch: Math.min(Math.max(maxLength + 2, 10), 50) };
        });
        ws['!cols'] = colWidths;

        XLSX.utils.book_append_sheet(wb, ws, 'Survey Responses');
        
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `Crime_Festival_2025_Survey_Data_${timestamp}.xlsx`;

        XLSX.writeFile(wb, filename, { 
            bookType: 'xlsx',
            type: 'binary',
            compression: true
        });

		document.body.removeChild(statusDiv);
        alert(`✅ Exported: ${filename}`);
        console.log('✅ Export completed successfully');

	} catch (error) {
        console.error('❌ Export error:', error);
        alert('❌ Export failed! (Check console)');
        const statusDiv = document.querySelector('div[style*="position: fixed"]');
        if (statusDiv) {
            document.body.removeChild(statusDiv);
        }
    }
}

function setupLeaderboardButtonListener() {
    if (!window.firebaseDB) {
        setTimeout(setupLeaderboardButtonListener, 500);
        return;
    }
    
    const docRef = window.firebaseDoc(window.firebaseDB, 'config', 'leaderboard');
    
    const unsubscribe = window.firebaseOnSnapshot(docRef, 
        async (doc) => {
            const btn = document.getElementById('leaderboardToggleBtn');
            const isUnlocked = doc.data()?.unlocked || false;
            
            if (btn) {
                btn.innerHTML = isUnlocked 
                    ? '🔓 LEADERBOARD (TEAMS)' 
                    : '🔒 LEADERBOARD (TEAMS)';
                btn.style.background = isUnlocked ? '#28a745' : '#dc3545';
            }
        },
        (error) => {
            console.error('Error listening to leaderboard config:', error);
        }
    );
    
    console.log('✅ Leaderboard button listener active');
}

async function openAlertModal() {
    const modal = document.getElementById('alertModal');
    const select = document.getElementById('alertTarget');
    
    const teams = await getAllTeams();
    const options = ['<option value="all">📢 ΟΛΕΣ ΟΙ ΟΜΑΔΕΣ</option>'];
    
    teams.forEach(team => {
        options.push(`<option value="${team.name}">👥 ${team.name.toUpperCase()}</option>`);
    });
    
    select.innerHTML = options.join('');
    modal.classList.add('active');
}

function closeAlertModal() {
    const modal = document.getElementById('alertModal');
    modal.classList.remove('active');
    document.getElementById('alertMessage').value = '';
    document.getElementById('alertTarget').value = 'all';
}

async function sendAlert() {
    const message = document.getElementById('alertMessage').value.trim();
    const target = document.getElementById('alertTarget').value;
    
    if (!message) {
        alert('⚠️ Παρακαλώ εισάγετε μήνυμα!');
        return;
    }
    
    if (!window.firebaseDB) {
        alert('❌ Firebase δεν είναι διαθέσιμο!');
        return;
    }
    
    try {
        const alertData = {
            message: message,
            targetTeam: target,
            timestamp: new Date().toISOString(),
            read: false,
            sender: 'admin'
        };
        
        const alertId = `alert_${Date.now()}`;
        const alertRef = window.firebaseDoc(window.firebaseDB, 'alerts', alertId);
        
		await window.firebaseSetDoc(alertRef, alertData);
        
        closeAlertModal();
        alert('✅ Η ΕΙΔΟΠΟΙΗΣΗ ΣΤΑΛΘΗΚΕ!');
        
    } catch (error) {
        console.error('Error sending alert:', error);
        alert(`❌ ΣΦΑΛΜΑ ΑΠΟΣΤΟΛΗΣ`);
    }
}

let firestoreUnsubscribe = null;
let lastKnownTeamsState = {};
let pollingInterval = null;
let isFirestoreActive = false;

function startPolling() {
    if (pollingInterval) return;
    console.log('📡 Starting polling mode (every 3 seconds)');
    pollingInterval = setInterval(refreshTeams, 3000);
}

function stopPolling() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
        console.log('🛑 Polling stopped');
    }
}

function setupRealtimeListener() {
    if (!isFirebaseReady()) {
        console.warn('⚠️ Firebase not ready - using periodic refresh');
        startPolling();
        return;
    }

    try {
        const teamsCollection = window.firebaseCollection(window.firebaseDB, 'teams');
        firestoreUnsubscribe = window.firebaseOnSnapshot(teamsCollection, 
            (snapshot) => {
                console.log('🔥 Firebase real-time update received');
                isFirestoreActive = true;
                stopPolling();
                
                let hasChanges = false;
                
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added' || change.type === 'modified') {
                        console.log(`🔍 Team ${change.doc.id} was ${change.type}`);
                        hasChanges = true;
                    }
                    if (change.type === 'removed') {
                        console.log(`🗑️ Team ${change.doc.id} was removed`);
                        hasChanges = true;
                    }
                });
                
                if (hasChanges) {
                    debouncedRefreshTeams();
                }
            },
            (error) => {
                console.error('❌ Firebase listener error:', error);
                isFirestoreActive = false;
                startPolling();
            }
        );
        
        console.log('✅ Real-time Firebase listener active');
        
    } catch (error) {
        console.error('❌ Failed to setup Firebase listener:', error);
        setInterval(refreshTeams, 2000);
    }
}


function showSyncStatus(message, type = 'success') {
    const status = document.getElementById('firebaseStatus');
    if (!status) return;
    
    status.classList.remove('syncing');
    
    if (type === 'syncing') {
        status.classList.add('syncing');
        status.style.background = '#17a2b8';
    } else if (type === 'success') {
        status.style.background = '#28a745';
    } else if (type === 'error') {
        status.style.background = '#dc3545';
    }
    
    status.innerHTML = message;
    status.style.display = 'block';
    
    if (type !== 'syncing') {
        setTimeout(() => {
            status.style.display = 'none';
        }, 3000);
    }
}

function toggleAdminMode() {
    const mode = document.getElementById('adminMode').value;
    const allH3 = document.querySelectorAll('.section h3');
    let testingSection = null;
    let dangerSection = null;
    
    allH3.forEach(h3 => {
        if (h3.textContent.includes('Testing & Debug Tools') || h3.textContent.includes('🧪')) {
            testingSection = h3;
        }
        if (h3.textContent.includes('Danger Zone') || h3.textContent.includes('⚠️')) {
            dangerSection = h3;
        }
    });
    
    if (!testingSection || !dangerSection) {
        console.warn('⚠️ Admin sections not found yet');
        return;
    }
    
    const testingButtons = testingSection.nextElementSibling;
    const dangerButtons = dangerSection.nextElementSibling;
    
    if (mode === 'live') {
        testingSection.style.display = 'none';
        testingButtons.style.display = 'none';
        dangerSection.style.display = 'none';
        dangerButtons.style.display = 'none';
        
        console.log('🎮 LIVE EVENT MODE: Testing tools hidden');
    } else {
        testingSection.style.display = 'block';
        testingButtons.style.display = 'grid';
        dangerSection.style.display = 'block';
        dangerButtons.style.display = 'grid';
        
        console.log('🧪 TESTING MODE: All tools visible');
    }
    
    localStorage.setItem('adminMode', mode);
}

window.addEventListener('DOMContentLoaded', async () => {
    const savedMode = localStorage.getItem('adminMode') || 'live';
    const modeSelect = document.getElementById('adminMode');
    if (modeSelect) {
        modeSelect.value = savedMode;
        toggleAdminMode();
    }
    
    function checkFirestoreConnection() {
        if (!window.firebaseDB) return false;
        
        const testRef = window.firebaseDoc(window.firebaseDB, 'config', 'test');
        window.firebaseGetDoc(testRef)
            .then(() => {
                console.log('🟢 Firestore connection active');
                showSyncStatus('✅ Connected', 'success');
            })
            .catch((error) => {
                console.error('🔴 Firestore connection failed:', error);
                showSyncStatus('⚠️ Connection issues', 'error');
            });
    }

    setInterval(checkFirestoreConnection, 30000);
    
    await refreshTeams();
    setupRealtimeListener();
    setupLeaderboardButtonListener();
    
    setTimeout(() => {
        const status = document.getElementById('firebaseStatus');
        if (status && !status.classList.contains('syncing')) {
            status.style.display = 'none';
        }
    }, 5000);
});

window.addEventListener('online', () => {
    console.log('🟢 Back online');
    showSyncStatus('🟢 Reconnecting...', 'syncing');
    if (!isFirestoreActive) {
        stopPolling();
        setupRealtimeListener();
    }
});

window.addEventListener('offline', () => {
    console.log('🔴 Offline');
    showSyncStatus('🔴 Offline - Changes may not save', 'error');
});

</script>
</body>
</html>