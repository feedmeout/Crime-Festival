<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="description" content="Crime Festival 2025 - Admin Management Panel">
    <title>Admin Panel - TEK Management</title>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, doc, setDoc, getDoc, getDocs, collection, deleteDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        const firebaseConfig = {
          apiKey: "AIzaSyA_9_40aa_wO_19g-1bIrSB6742aMOPwjo",
          authDomain: "crime-festival-2025.firebaseapp.com",
          projectId: "crime-festival-2025",
          storageBucket: "crime-festival-2025.firebasestorage.app",
          messagingSenderId: "663770004335",
          appId: "1:663770004335:web:e42dbd983ab9b5277bc69a"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        window.firebaseDB = db;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseGetDoc = getDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseCollection = collection;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseOnSnapshot = onSnapshot;
        console.log("✅ Firebase connected!");
    </script>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary-gradient: linear-gradient(135deg, #ff6b00 0%, #ff8800 100%);
    --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    --primary-color: #ff6b00;
    --primary-light: #ff8800;
    --success-color: #28a745;
    --danger-color: #dc3545;
    --info-color: #17a2b8;
    --secondary-color: #6c757d;
    --text-dark: #1a1a2e;
    --text-medium: #333;
    --text-light: #666;
    --text-lighter: #999;
    --border-color: #ddd;
    --border-light: #dee2e6;
    --bg-light: #f8f9fa;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.1);
    --shadow-md: 0 4px 15px rgba(0,0,0,0.15);
    --shadow-lg: 0 10px 40px rgba(0,0,0,0.3);
    --shadow-xl: 0 20px 60px rgba(0,0,0,0.5);
    --radius-sm: 5px;
    --radius-md: 8px;
    --radius-lg: 10px;
    --radius-xl: 12px;
    --transition: all 0.2s ease;
    --min-touch-target: 44px;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: var(--bg-gradient);
    min-height: 100vh;
    padding: clamp(10px, 3vw, 20px);
    overflow-x: hidden;
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    width: 100%;
}

.section {
    background: white;
    border-radius: var(--radius-xl);
    padding: clamp(15px, 4vw, 30px);
    margin-bottom: clamp(15px, 3vw, 20px);
    box-shadow: var(--shadow-lg);
}

.header {
    background: var(--primary-gradient);
    padding: clamp(15px, 4vw, 30px);
    border-radius: var(--radius-xl);
    text-align: center;
    margin-bottom: clamp(15px, 3vw, 20px);
    box-shadow: var(--shadow-lg);
}

.header h1 {
    color: white;
    font-size: clamp(18px, 5vw, 32px);
    margin-bottom: 8px;
    font-weight: 700;
    letter-spacing: -0.5px;
}

.header p {
    color: rgba(255,255,255,0.95);
    font-size: clamp(12px, 3vw, 16px);
    font-weight: 500;
}

.section h2 {
    color: var(--text-dark);
    font-size: clamp(18px, 4vw, 24px);
    margin-bottom: 15px;
    padding-bottom: 12px;
    border-bottom: 3px solid var(--primary-color);
    font-weight: 700;
}

.section h3 {
    color: var(--text-medium);
    font-size: clamp(16px, 3.5vw, 20px);
    margin: clamp(15px, 3vw, 20px) 0 10px;
    font-weight: 600;
}

.team-input {
    display: flex;
    flex-direction: column;
    gap: clamp(8px, 2vw, 12px);
    margin-bottom: 15px;
}

.team-input input,
.sort-controls select {
    width: 100%;
    padding: clamp(12px, 3vw, 16px);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    font-size: clamp(14px, 3vw, 16px);
    transition: var(--transition);
    min-height: var(--min-touch-target);
}

.team-input input:focus,
.sort-controls select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 107, 0, 0.1);
}

.btn {
    padding: clamp(12px, 3vw, 16px) clamp(16px, 4vw, 24px);
    border: none;
    border-radius: var(--radius-md);
    font-size: clamp(14px, 3vw, 15px);
    font-weight: 700;
    cursor: pointer;
    transition: var(--transition);
    width: 100%;
    min-height: var(--min-touch-target);
    text-align: center;
    display: inline-block;
    line-height: 1.4;
}

.btn:hover {
    transform: translateY(-2px);
}

.btn:active {
    transform: translateY(0);
}

.btn-primary {
    background: var(--primary-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(255,107,0,0.3);
}

.btn-primary:hover {
    box-shadow: 0 6px 20px rgba(255,107,0,0.5);
}

.btn-danger {
    background: var(--danger-color);
    color: white;
    box-shadow: 0 4px 15px rgba(220,53,69,0.3);
}

.btn-success {
    background: var(--success-color);
    color: white;
    box-shadow: 0 4px 15px rgba(40,167,69,0.3);
}

.btn-secondary {
    background: var(--secondary-color);
    color: white;
}

.sort-controls {
    display: flex;
    flex-direction: column;
    gap: clamp(8px, 2vw, 10px);
    margin-bottom: 15px;
    align-items: stretch;
}

.sort-controls label {
    font-weight: 700;
    color: var(--text-medium);
    font-size: clamp(13px, 3vw, 14px);
}

.quick-actions {
    display: grid;
    grid-template-columns: 1fr;
    gap: clamp(8px, 2vw, 10px);
    margin-bottom: 15px;
}

.team-list {
    display: grid;
    grid-template-columns: 1fr;
    gap: clamp(12px, 3vw, 20px);
    margin-top: 15px;
}

.team-card {
    background: var(--bg-light);
    border: 2px solid var(--border-light);
    border-radius: var(--radius-lg);
    padding: clamp(12px, 3vw, 20px) clamp(10px, 2.5vw, 15px);
    transition: var(--transition);
    overflow: hidden;
}

.team-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-md);
}

.team-card.completed {
    border: 3px solid var(--success-color);
    background: linear-gradient(135deg, #f0fff4 0%, #d4edda 100%);
}

.team-card h3 {
    color: #0f3460;
    font-size: clamp(16px, 4vw, 20px);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    line-height: 1.3;
}

.tek-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(max(40px, 8vw), 1fr));
    gap: clamp(4px, 1.5vw, 6px);
    margin: 12px 0;
    width: 100%;
}

.tek-box {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-sm);
    font-size: clamp(10px, 2.5vw, 12px);
    font-weight: 700;
    border: 2px solid var(--border-color);
    background: white;
    min-height: var(--min-touch-target);
    min-width: var(--min-touch-target);
    padding: 4px;
    transition: var(--transition);
}

.tek-box.unlocked {
    background: #d4edda;
    border-color: var(--success-color);
    color: #155724;
}

.tek-box.clickable {
    cursor: pointer;
}

.tek-box.clickable:hover {
    transform: scale(1.1);
    box-shadow: var(--shadow-sm);
}

.tek-box.clickable:active {
    transform: scale(0.95);
}

.tek-box.disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.tek-box.unlocked.clickable:hover {
    background: #b8dacc;
    border-color: #1e7e34;
}

.tek-box:not(.unlocked).clickable:hover {
    background: #fff3cd;
    border-color: #ffc107;
}

.team-actions {
    display: grid;
    grid-template-columns: 1fr;
    gap: clamp(6px, 1.5vw, 8px);
    margin-top: 12px;
}

.team-actions .btn {
    font-size: clamp(13px, 3vw, 14px);
    padding: clamp(10px, 2.5vw, 14px) clamp(12px, 3vw, 16px);
}

.progress-bar {
    background: #e0e0e0;
    height: clamp(25px, 6vw, 30px);
    border-radius: var(--radius-xl);
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    background: var(--primary-gradient);
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 700;
    font-size: clamp(11px, 2.5vw, 13px);
    transition: width 0.3s ease;
}

.team-stats {
    font-size: clamp(12px, 2.5vw, 14px);
    color: var(--text-light);
    margin-bottom: 8px;
    line-height: 1.5;
}

.team-stats strong {
    color: var(--text-medium);
}

.completion-badge {
    background: var(--success-color);
    color: white;
    padding: 4px 8px;
    border-radius: var(--radius-sm);
    font-size: clamp(9px, 2vw, 10px);
    font-weight: 700;
    display: inline-block;
    margin-left: 5px;
}

.alert {
    padding: clamp(12px, 3vw, 15px) clamp(15px, 4vw, 20px);
    border-radius: var(--radius-md);
    margin-bottom: clamp(15px, 3vw, 20px);
    font-size: clamp(13px, 3vw, 14px);
    line-height: 1.5;
}

.alert-success {
    background: #d4edda;
    border: 1px solid #c3e6cb;
    color: #155724;
}

.alert-danger {
    background: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #721c24;
}

.alert-warning {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    color: #856404;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    overflow: auto;
    padding: clamp(10px, 3vw, 20px);
}

.modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: white;
    padding: clamp(15px, 4vw, 30px);
    border-radius: var(--radius-xl);
    max-width: 700px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: var(--shadow-xl);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 12px;
    border-bottom: 2px solid var(--primary-color);
}

.modal-header h2 {
    color: var(--text-dark);
    font-size: clamp(18px, 4vw, 24px);
    margin: 0;
    padding: 0;
    border: none;
}

.close-modal {
    font-size: clamp(24px, 6vw, 28px);
    cursor: pointer;
    color: var(--text-lighter);
    line-height: 1;
    padding: 5px 10px;
    transition: var(--transition);
    min-width: var(--min-touch-target);
    min-height: var(--min-touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-modal:hover {
    color: var(--text-medium);
}

.info-box {
    padding: clamp(12px, 3vw, 15px);
    border-radius: var(--radius-md);
    margin-bottom: clamp(15px, 3vw, 20px);
    font-size: clamp(12px, 2.5vw, 14px);
    line-height: 1.6;
}

.info-box-start {
    background: #e3f2fd;
    border-left: 3px solid #2196f3;
}

.info-box-complete {
    background: #d4edda;
    border-left: 3px solid var(--success-color);
}

.info-box strong {
    display: block;
    margin-bottom: 5px;
    font-weight: 700;
}

.timestamp-list {
    list-style: none;
    padding: 0;
}

.timestamp-item {
    padding: clamp(10px, 3vw, 12px);
    margin-bottom: 8px;
    background: var(--bg-light);
    border-left: 3px solid var(--primary-color);
    border-radius: var(--radius-sm);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
}

.timestamp-item .tek-label {
    font-weight: 700;
    color: #0f3460;
    font-size: clamp(13px, 3vw, 14px);
}

.timestamp-item .time {
    color: var(--text-light);
    font-size: clamp(12px, 2.5vw, 13px);
}

#firebaseStatus {
    position: fixed;
    bottom: clamp(15px, 3vw, 20px);
    right: clamp(15px, 3vw, 20px);
    background: var(--success-color);
    color: white;
    padding: clamp(10px, 3vw, 12px) clamp(15px, 4vw, 20px);
    border-radius: var(--radius-md);
    font-size: clamp(10px, 2.5vw, 11px);
    box-shadow: var(--shadow-md);
    display: none;
    max-width: min(250px, calc(100vw - 40px));
    line-height: 1.4;
    z-index: 9999;
    transition: var(--transition);
}

#firebaseStatus.syncing {
    background: var(--info-color);
    animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@media (min-width: 480px) {
    .team-input {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .team-input input {
        flex: 1;
        min-width: min(200px, 100%);
    }
    
    .btn {
        width: auto;
    }
    
    .quick-actions {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    
    .team-actions {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
    
    .sort-controls {
        flex-direction: row;
        align-items: center;
    }
    
    .sort-controls select {
        width: auto;
        min-width: 200px;
    }
}

@media (min-width: 768px) {
    .tek-grid {
        grid-template-columns: repeat(11, minmax(0, 1fr));
        gap: clamp(5px, 1vw, 6px);
    }
    
    .tek-box {
        font-size: clamp(9px, 1vw, 11px);
        min-width: 38px;
        min-height: 38px;
        border-width: 1px;
        padding: 3px;
    }
    
    .team-list {
        grid-template-columns: repeat(auto-fill, minmax(min(420px, 100%), 1fr));
    }
}

@media (min-width: 1024px) {
    .team-list {
        grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
    }
}

@media (max-height: 600px) and (orientation: landscape) {
    .header {
        padding: clamp(10px, 2vw, 15px);
        margin-bottom: clamp(10px, 2vw, 15px);
    }
    
    .section {
        padding: clamp(12px, 3vw, 15px);
        margin-bottom: clamp(10px, 2vw, 15px);
    }
    
    .modal-content {
        max-height: 85vh;
    }
}

@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}
</style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🔒 CRIME MANAGEMENT - ADMIN PANEL</h1>
            <p>ΔΙΑΧΕΙΡΙΣΗ ΟΜΑΔΩΝ & ΠΑΡΑΚΟΛΟΥΘΗΣΗ ΠΡΟΟΔΟΥ</p>
        </div>
    
        <div class="section">
            <h2>➕ ΠΡΟΣΘΗΚΗ ΟΜΑΔΑΣ</h2>
            <div class="team-input">
                <input type="text" id="newTeamName" placeholder="ΟΝΟΜΑ" />
                <input type="text" id="newTeamPassword" placeholder="ΚΩΔΙΚΟΣ" />
                <input type="number" id="newTeamSize" placeholder="ΜΕΛΗ (1-10)" min="1" max="10" />
                <button class="btn btn-primary" onclick="addTeam()">ΠΡΟΣΘΗΚΗ ΟΜΑΔΑΣ</button>
            </div>
            <div id="addTeamAlert"></div>
        </div>

        <div class="section">
            <h2>👥 ΕΝΕΡΓΕΣ ΟΜΑΔΕΣ</h2>
            <div class="quick-actions">
                <button class="btn" style="background: #17a2b8; color: white;" onclick="exportAllData()">💾 EXPORT DATA (GAME)</button>
                <button class="btn" style="background: #6c757d; color: white;" onclick="importData()">📥 IMPORT DATA (GAME)</button>
				<button class="btn" style="background: #059669; color: white;" onclick="exportSurveyDataToExcel()">📊 EXPORT SURVEYS (EXCEL)</button>
                <button class="btn" style="background: #ffc107; color: #000;" onclick="window.location.href='leaderboard.html'">🏆 LEADERBOARD (ADMIN)</button>
                <button class="btn" id="leaderboardToggleBtn" style="background: #dc3545; color: white;" onclick="toggleLeaderboard()">
                    🔒 LOADING...
                </button>
                <button class="btn btn-secondary" onclick="unlockAllForAll()">🔓 ΤΕΚΜΗΡΙΑ (ΟΛΑ)</button>
                <button class="btn btn-danger" onclick="resetAll()">🗑️ ΔΙΑΓΡΑΦΗ ΟΜΑΔΩΝ (ΟΛΕΣ)</button>
            </div>
            
            <div class="sort-controls">
                <label>ΤΑΞΙΝΟΜΗΣΗ:</label>
                <select id="sortOrder" onchange="refreshTeams()">
                    <option value="name">ΟΝΟΜΑ</option>
                    <option value="progress">ΠΡΟΟΔΟΣ</option>
                    <option value="completion">ΧΡΟΝΟΣ ΟΛΟΚΛΗΡΩΣΗΣ (ΤΑΧΥΤΕΡΟ)</option>
                    <option value="recent">ΠΙΟ ΠΡΟΣΦΑΤΟ</option>
                </select>
            </div>
            
            <div id="teamsContainer" class="team-list"></div>
        </div>
    </div>

    <div id="timestampModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTeamName">ΧΡΟΝΙΚΑ ΣΗΜΕΙΑ</h2>
                <span class="close-modal" onclick="closeModal()">&times;</span>
            </div>
            <div id="modalContent"></div>
        </div>
    </div>

    <div id="firebaseStatus">
        ✅ Firebase Connected - Data Synced to Cloud
    </div>

<script>
let teamsData = {};
    const BASE_URL = window.location.origin + window.location.pathname.replace('admin.html', '');
    const TOTAL_TEKS = 11;
    
    function isFirebaseReady() {
        return typeof window.firebaseDB !== 'undefined';
    }

    function formatTime(ms) {
        if (!ms) return 'N/A';
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        
        const h = hours;
        const m = minutes % 60;
        const s = seconds % 60;
        
        if (h > 0) {
            return `${h}ω ${m}λ ${s}δ`;
        } else if (m > 0) {
            return `${m}λ ${s}δ`;
        } else {
            return `${s}δ`;
        }
    }

    function formatDateTime(isoString) {
        if (!isoString) return 'N/A';
        return new Date(isoString).toLocaleString('el-GR', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }

    async function saveTeamToFirebase(teamName, data) {
        if (!isFirebaseReady()) return false;
        try {
            await window.firebaseSetDoc(
                window.firebaseDoc(window.firebaseDB, 'teams', teamName),
                { ...data, lastUpdate: new Date().toISOString() }
            );
            console.log('✅ Firebase save successful');
            return true;
        } catch (error) {
            console.error('❌ Firebase save error:', error);

            const status = document.getElementById('firebaseStatus');
            if (status) {
                status.style.background = '#dc3545';
                status.innerHTML = '⚠️ Firebase Sync Failed - Using Local Storage';
                status.style.display = 'block';
            }
            
            return false;
        }
    }

    async function loadTeamFromFirebase(teamName) {
        if (!isFirebaseReady()) return null;
        try {
            const docRef = window.firebaseDoc(window.firebaseDB, 'teams', teamName);
            const docSnap = await window.firebaseGetDoc(docRef);
            return docSnap.exists() ? docSnap.data() : null;
        } catch (error) {
            console.error('Firebase load error:', error);
            return null;
        }
    }

    async function getAllTeamsFromFirebase() {
        if (!isFirebaseReady()) return [];
        try {
            const querySnapshot = await window.firebaseGetDocs(
                window.firebaseCollection(window.firebaseDB, 'teams')
            );
            const teams = [];
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                
                if (!data.deleted) {
                    teams.push({ name: doc.id, ...data });
                }
            });
            
            console.log(`🔥 Firebase returned ${teams.length} teams`);
            return teams;
        } catch (error) {
            console.error('Firebase load all error:', error);
            return [];
        }
    }

async function getAllTeams() {
        const allTeams = new Map();
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('unlocked_teks_')) {
                const teamName = key.replace('unlocked_teks_', '');
                const storedData = JSON.parse(localStorage.getItem(key));

                if (Array.isArray(storedData)) {
                    allTeams.set(teamName, { 
                        name: teamName, 
                        unlocked: storedData,
                        timestamps: {},
                        startTime: null,
                        completedAt: null,
                        totalTimeMs: null,
                        solution: null,
                        lastUpdate: null,
                        teamSize: null,
                        password: null,
                        evidenceTimestamps: {},
                        source: 'localStorage-legacy'
                    });
                } else {
                    allTeams.set(teamName, {
                        name: teamName,
                        password: storedData.password || null,
                        teamSize: storedData.teamSize || null,
                        unlocked: storedData.unlocked || [],
                        timestamps: storedData.timestamps || {},
                        evidenceTimestamps: storedData.evidenceTimestamps || {},
                        startTime: storedData.startTime || null,
                        completedAt: storedData.completedAt || null,
                        totalTimeMs: storedData.totalTimeMs || null,
                        solution: storedData.solution || null,
                        lastUpdate: storedData.lastUpdate || null,
                        source: 'localStorage'
                    });
                }
            }
        }

        if (isFirebaseReady()) {
            try {
                const firebaseTeams = await getAllTeamsFromFirebase();
                firebaseTeams.forEach(team => {
                    console.log(`📦 Processing team ${team.name} from Firebase`);
                    
                    const localTeam = allTeams.get(team.name);
                    
                    if (!localTeam) {
                        allTeams.set(team.name, {
                            name: team.name,
                            password: team.password || null,
                            teamSize: team.teamSize || null,
                            unlocked: team.unlocked || [],
                            timestamps: team.timestamps || {},
                            evidenceTimestamps: team.evidenceTimestamps || {},
                            startTime: team.startTime || null,
                            completedAt: team.completedAt || null,
                            totalTimeMs: team.totalTimeMs || null,
                            lastUpdate: team.lastUpdate || null,
                            solution: team.solution || null,
                            source: 'firebase'
                        });
                    } else {
                        const teamLastUpdate = team.lastUpdate || '0';
                        const localLastUpdate = localTeam.lastUpdate || '0';
                        const mergedTeamSize = team.teamSize || localTeam.teamSize || null;
                        const mergedPassword = team.password || localTeam.password || null;
                        
                        if (teamLastUpdate > localLastUpdate) {
                            console.log(`🔥 Firebase data is newer for ${team.name}`);
                            allTeams.set(team.name, {
                                name: team.name,
                                password: mergedPassword,
                                teamSize: mergedTeamSize,
                                unlocked: team.unlocked || [],
                                timestamps: team.timestamps || {},
                                evidenceTimestamps: team.evidenceTimestamps || {},
                                startTime: team.startTime || null,
                                completedAt: team.completedAt || null,
                                totalTimeMs: team.totalTimeMs || null,
                                lastUpdate: team.lastUpdate || null,
                                solution: team.solution || null,
                                source: 'firebase-newer'
                            });
                        } else {
                            console.log(`💾 localStorage data is current for ${team.name}, but preserving teamSize`);
                            localTeam.teamSize = mergedTeamSize;
                            localTeam.password = mergedPassword;
                        }
                    }
                });
            } catch (error) {
                console.error('⚠️ Firebase load failed, using localStorage only:', error);
            }
        }
        
        const teams = Array.from(allTeams.values());
        console.log(`📊 Loaded ${teams.length} teams total`);
        return teams;
    }

async function saveTeam(teamName, data) {
    const existingTeam = teamsData[teamName];
    if (existingTeam && existingTeam.teamSize && !data.teamSize) {
        console.warn(`⚠️ teamSize missing in save, preserving existing value: ${existingTeam.teamSize}`);
        data.teamSize = existingTeam.teamSize;
    }
    
    if (data.teamSize !== undefined && data.teamSize !== null) {
        data.teamSize = parseInt(data.teamSize);
        if (isNaN(data.teamSize) || data.teamSize < 1) {
            console.error(`Invalid teamSize for team ${teamName}:`, data.teamSize);
            alert('Error: Invalid team size!');
            return false;
        }
    }
    
    data.lastUpdate = new Date().toISOString();
    
    console.log(`💾 Saving team ${teamName} with data:`, {
        teamSize: data.teamSize,
        unlocked: data.unlocked?.length,
        hasPassword: !!data.password
    });
    
    localStorage.setItem(`unlocked_teks_${teamName}`, JSON.stringify(data));
    teamsData[teamName] = { name: teamName, ...data };
    
    const firebaseSuccess = await saveTeamToFirebase(teamName, data);
    
    if (!firebaseSuccess) {
        console.warn('⚠️ Continuing with localStorage only for team:', teamName);
    }
    
    if (firebaseSuccess && window.firebaseDB) {
        const docRef = window.firebaseDoc(window.firebaseDB, 'teams', teamName);
        const verify = await window.firebaseGetDoc(docRef);
        if (verify.exists()) {
            const saved = verify.data();
            console.log('✅ Verified team saved with teamSize:', saved.teamSize);
            if (!saved.teamSize || saved.teamSize < 1) {
                console.error('❌ teamSize not saved correctly!', saved);
            }
        }
    }
    
    refreshTeams();
    
    return true;
}

    async function exportAllData() {
        const teams = await getAllTeams();
        
        const dataStr = JSON.stringify({ 
            exportDate: new Date().toISOString(),
            teams: teams 
        }, null, 2);
        
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `crime-festival-backup-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        alert(`✅ Exported ${teams.length} teams to JSON file!`);
    }

    function importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            const text = await file.text();
            const data = JSON.parse(text);
            
            let imported = 0;
            for (const team of data.teams) {
                await saveTeam(team.name, team);
                imported++;
            }
            
            alert(`✅ Imported ${imported} teams!`);
            refreshTeams();
        };
        
        input.click();
    }

async function addTeam() {
    const alertDiv = document.getElementById('addTeamAlert');
    const teamName = document.getElementById('newTeamName').value.trim().toLowerCase();
    const password = document.getElementById('newTeamPassword').value.trim();
    const teamSize = parseInt(document.getElementById('newTeamSize').value);

    if (!teamName) {
        alertDiv.innerHTML = '<div class="alert alert-danger">⚠️ Παρακαλώ εισάγετε όνομα ομάδας</div>';
        return;
    }

    if (!password) {
        alertDiv.innerHTML = '<div class="alert alert-danger">⚠️ Παρακαλώ εισάγετε κωδικό ομάδας</div>';
        return;
    }

    if (!teamSize || teamSize < 1 || teamSize > 10) {
        alertDiv.innerHTML = '<div class="alert alert-danger">⚠️ Παρακαλώ εισάγετε αριθμό μελών (1-10)</div>';
        return;
    }

    if (isFirebaseReady()) {
        const docRef = window.firebaseDoc(window.firebaseDB, 'teams', teamName);
        const docSnap = await window.firebaseGetDoc(docRef);
        if (docSnap.exists()) {
            alertDiv.innerHTML = '<div class="alert alert-warning">⚠️ Η ομάδα υπάρχει ήδη</div>';
            return;
        }
    }
    const teamData = {
        password: password,
        teamSize: teamSize,
        unlocked: [],
        timestamps: {},
        evidenceTimestamps: {},
        startTime: null,
        completedAt: null,
        totalTimeMs: null,
        solution: null,
        createdAt: new Date().toISOString()
    };
    
    console.log('Creating team with data:', teamData); 
    
    await saveTeam(teamName, teamData);
    
    alertDiv.innerHTML = `<div class="alert alert-success">✅ Η ομάδα "${teamName}" δημιουργήθηκε με κωδικό: <strong>${password}</strong> και <strong>${teamSize} μέλη</strong></div>`;
    document.getElementById('newTeamName').value = '';
    document.getElementById('newTeamPassword').value = '';
    document.getElementById('newTeamSize').value = '';
    
    setTimeout(() => { alertDiv.innerHTML = ''; }, 5000);
    refreshTeams();
}

async function refreshTeams() {
    console.log('🔄 === REFRESH TEAMS START ===');
    showSyncStatus('🔄 Syncing data...', 'syncing');
    
    let teams = await getAllTeams();
    teamsData = {};
    teams.forEach(team => {
        teamsData[team.name] = team;
    });
    
    const container = document.getElementById('teamsContainer');
    const sortOrder = document.getElementById('sortOrder').value;

    console.log(`📊 Loaded ${teams.length} teams from Firebase/localStorage`);
    teams.forEach(t => console.log(`  - ${t.name}: ${t.unlocked.length} TEKs unlocked, data:`, t.unlocked));

if (teams.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;"></div>';
        if (window.timerInterval) {
            clearInterval(window.timerInterval);
        }
        
        showSyncStatus('✅ Data synced', 'success');
        console.log('🔄 === REFRESH TEAMS END ===');
        return;
    }
    
    teams = sortTeams(teams, sortOrder);
    container.innerHTML = '';    
    if (window.timerInterval) {
        clearInterval(window.timerInterval);
    }

window.timerInterval = setInterval(() => {
    document.querySelectorAll('.team-card').forEach(teamCard => {
        const teamName = teamCard.dataset.teamId;
        const team = teamsData[teamName];
        
        if (team && team.startTime && !team.completedAt && !team.solution) {
            const elapsed = Date.now() - new Date(team.startTime).getTime();
            const timerStats = Array.from(teamCard.querySelectorAll('.team-stats')).find(
                el => el.textContent.includes('ΣΕ ΕΞΕΛΙΞΗ')
            );
            
            if (timerStats) {
                timerStats.innerHTML = `⏱️ ΧΡΟΝΟΣ ΣΕ ΕΞΕΛΙΞΗ: <strong>${formatTime(elapsed)}</strong>`;
            }
        }
    });
}, 1000);
    
    const html = teams.map(team => {
        const progress = Math.round((team.unlocked.length / TOTAL_TEKS) * 100);
        const allEvidenceUnlocked = team.unlocked.length === TOTAL_TEKS;
        const solutionSubmitted = !!team.solution;
        
        let timingHtml = '';
        if (team.startTime) {
            const now = new Date();
            const startTime = new Date(team.startTime);
            
            if (solutionSubmitted && team.completedAt) {
                timingHtml = `
                    <div class="team-stats">⏱️ ΧΡΟΝΟΣ ΟΛΟΚΛΗΡΩΣΗΣ: <strong>${formatTime(team.totalTimeMs)}</strong></div>
                `;
            } else {
                const elapsed = now - startTime;
                timingHtml = `
                    <div class="team-stats">⏱️ ΧΡΟΝΟΣ ΣΕ ΕΞΕΛΙΞΗ: <strong>${formatTime(elapsed)}</strong></div>
                `;
            }
        }
  
        console.log(`🎨 Rendering team ${team.name} with unlocked:`, team.unlocked);
            
        return `
            <div class="team-card ${solutionSubmitted ? 'completed' : ''}" data-team-id="${team.name}">
                <h3>
                    <span style="font-size: 24px;">👥</span> 
                    ${team.name.toUpperCase()}
                    ${solutionSubmitted ? 
                        '<span class="completion-badge">✅ ΟΛΟΚΛΗΡΩΘΗΚΕ</span>' : 
                        (allEvidenceUnlocked ? '<span class="completion-badge" style="background: #17a2b8;">📦 ΠΛΗΡΗΣ ΣΥΛΛΟΓΗ</span>' : '')
                    }
                </h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${progress}%;">${progress}%</div>
                </div>
                <div class="team-stats">📊 ΞΕΚΛΕΙΔΩΜΕΝΑ: ${team.unlocked.length} / ${TOTAL_TEKS} ΣΤΟΙΧΕΙΑ</div>
                <div class="team-stats">👥 ΜΕΛΗ: <strong>${team.teamSize || 'N/A'}</strong></div>
                <div class="team-stats">🔑 ΚΩΔΙΚΟΣ: <strong>${team.password || 'N/A'}</strong></div>
                ${timingHtml}
                <div class="tek-grid">
                    ${Array.from({length: TOTAL_TEKS}, (_, i) => {
                        const tekNum = (i + 1).toString();
                        const isUnlocked = team.unlocked.includes(tekNum);
                        const isLocked = !!team.solution;
                        
                        console.log(`  TEK ${tekNum}: unlocked=${isUnlocked}, array contains:`, team.unlocked);
                        
                        return `<div class="tek-box ${isUnlocked ? 'unlocked' : ''} ${isLocked ? 'disabled' : 'clickable'}" 
                                     onclick="${isLocked ? '' : `toggleTek('${team.name}', ${i + 1})`}" 
                                     title="${isLocked ? 'Κλειδωμένο (λύση υποβλήθηκε)' : (isUnlocked ? 'Κλικ για κλείδωμα' : 'Κλικ για ξεκλείδωμα')}">${i + 1}</div>`;
                    }).join('')}
                </div>
                <div class="team-actions">
                    <button class="btn btn-primary" onclick="viewTeam('${team.name}')">👁️ ΠΡΟΒΟΛΗ</button>
                    <button class="btn" style="background: #17a2b8; color: white;" onclick="showTimestamps('${team.name}')">🕐 ΧΡΟΝΙΚΑ</button>
                    <button class="btn btn-success" onclick="unlockAll('${team.name}')">🔓 ΤΕΚΜΗΡΙΑ (ΟΛΑ)</button>
                    <button class="btn btn-secondary" onclick="resetTeam('${team.name}')">🔄 RESET</button>
                    <button class="btn btn-danger" onclick="deleteTeam('${team.name}')">🗑️ ΔΙΑΦΡΑΦΗ</button>
                </div>
            </div>
        `;
    }).join('');
    
container.innerHTML = html;
    showSyncStatus('✅ Data synced', 'success');
    console.log('🔄 === REFRESH TEAMS END ===');
}

    function sortTeams(teams, order) {
        switch(order) {
            case 'name':
                return teams.sort((a, b) => a.name.localeCompare(b.name));
            
            case 'progress':
                return teams.sort((a, b) => b.unlocked.length - a.unlocked.length);
            
            case 'completion':
                const completed = teams.filter(t => t.completedAt).sort((a, b) => a.totalTimeMs - b.totalTimeMs);
                const incomplete = teams.filter(t => !t.completedAt).sort((a, b) => b.unlocked.length - a.unlocked.length);
                return [...completed, ...incomplete];
            
            case 'recent':
                return teams.sort((a, b) => {
                    const aTime = a.lastUpdate || a.startTime || '0';
                    const bTime = b.lastUpdate || b.startTime || '0';
                    return bTime.localeCompare(aTime);
                });
            
            default:
                return teams;
        }
    }

async function showTimestamps(teamName) {
    const teams = await getAllTeams();
    const team = teams.find(t => t.name === teamName);
    
    if (!team) return;

    const modal = document.getElementById('timestampModal');
    const modalTeamName = document.getElementById('modalTeamName');
    const modalContent = document.getElementById('modalContent');

    modalTeamName.textContent = `ΧΡΟΝΙΚΑ ΣΗΜΕΙΑ - ${teamName.toUpperCase()}`;

    let html = '';
    if (team.startTime || team.completedAt) {
        html += '<div class="info-box info-box-start">';
        html += '<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; margin-bottom: 10px;">';
        
        if (team.startTime) {
            html += `<div><strong>🚀 Έναρξη:</strong> ${formatDateTime(team.startTime)}</div>`;
        }
        
        if (team.completedAt) {
            html += `<div><strong>🏁 Ολοκλήρωση:</strong> ${formatDateTime(team.completedAt)}</div>`;
        }
        
        html += '</div>';
        
        if (team.completedAt && team.totalTimeMs) {
            html += `<div><strong>⏱️ Συνολικός Χρόνος:</strong> ${formatTime(team.totalTimeMs)}</div>`;
        }
        
        html += '</div>';
    }

    if (team.timestamps && Object.keys(team.timestamps).length > 0) {
        html += '<h3 style="margin: 20px 0 10px 0;">Ξεκλειδώματα ΤΕΚ:</h3>';
        html += '<ul class="timestamp-list">';
        const sortedTeks = Object.entries(team.timestamps)
            .sort((a, b) => new Date(a[1]) - new Date(b[1]));
        
        sortedTeks.forEach(([tek, timestamp]) => {
            html += `
                <li class="timestamp-item">
                    <span class="tek-label">ΤΕΚ #${tek.padStart(2, '0')}</span>
                    <span class="time">${formatDateTime(timestamp)}</span>
                </li>
            `;
        });
        
        html += '</ul>';
    } else {
        html += '<p style="color: #999; text-align: center; padding: 20px;">Δεν υπάρχουν χρονικά δεδομένα</p>';
    }

    modalContent.innerHTML = html;
    modal.classList.add('active');
}
    function closeModal() {
        const modal = document.getElementById('timestampModal');
        modal.classList.remove('active');
    }
    
    window.onclick = function(event) {
        const modal = document.getElementById('timestampModal');
        if (event.target === modal) {
            closeModal();
        }
    }

function viewTeam(teamName) {
    window.open(`${BASE_URL}index.html?team=${teamName}`, '_blank');
}

async function toggleTek(teamName, tekNumber) {
    console.log(`🎯 Toggle TEK ${tekNumber} for team ${teamName}`);
    
    const teams = await getAllTeams();
    const team = teams.find(t => t.name === teamName);
    
    if (!team) {
        alert('Ομάδα δεν βρέθηκε!');
        return;
    }
    
    if (team.solution) {
        alert('❌ Δεν μπορείτε να τροποποιήσετε τεκμήρια μετά την υποβολή λύσης!');
        return;
    }
    
    const tekStr = tekNumber.toString();
    const unlocked = [...(team.unlocked || [])];
    const timestamps = {...(team.timestamps || {})};
    
    if (unlocked.includes(tekStr)) {
        const index = unlocked.indexOf(tekStr);
        unlocked.splice(index, 1);
        delete timestamps[tekStr];
        console.log(`🔒 Locked TEK ${tekNumber} for team ${teamName}`);
    } else {
        unlocked.push(tekStr);
        timestamps[tekStr] = new Date().toISOString();
        console.log(`🔓 Unlocked TEK ${tekNumber} for team ${teamName}`);
    }
    
const updatedTeam = {
    password: team.password || null,
    teamSize: team.teamSize !== undefined ? team.teamSize : null,
    unlocked: unlocked,
    timestamps: timestamps,
    evidenceTimestamps: team.evidenceTimestamps || {},
    startTime: team.startTime || new Date().toISOString(),
    completedAt: team.completedAt || null,
    totalTimeMs: team.totalTimeMs || null,
    solution: team.solution || null,
    lastUpdate: new Date().toISOString()
};
    
    console.log(`💾 Saving team ${teamName} with ${unlocked.length} TEKs`);
    await saveTeam(teamName, updatedTeam);
    await refreshTeams();
    
    console.log('✅ Toggle complete');
}

async function unlockAll(teamName) {
    if (confirm(`ΞΕΚΛΕΙΔΩΜΑ ΟΛΩΝ ΤΩΝ ΤΕΚΜΗΡΙΩΝ ΓΙΑ ΤΗΝ ΟΜΑΔΑ "${teamName}";`)) {
        console.log(`🔓 Unlocking all TEKs for team ${teamName}`);
        const teams = await getAllTeams();
        const team = teams.find(t => t.name === teamName);
        
        const allTeks = Array.from({length: TOTAL_TEKS}, (_, i) => (i + 1).toString());
        const now = new Date().toISOString();
        const timestamps = {...(team?.timestamps || {})};
        let earliestTime = team?.startTime || now;
        
        allTeks.forEach((tek, i) => {
            if (!timestamps[tek]) {
                timestamps[tek] = new Date(Date.now() + i * 100).toISOString();
            } else {
                const existingTime = new Date(timestamps[tek]);
                if (existingTime < new Date(earliestTime)) {
                    earliestTime = timestamps[tek];
                }
            }
        });
    
const updatedTeam = {
    password: team?.password || null,
    teamSize: team?.teamSize !== undefined ? team.teamSize : null,
    unlocked: allTeks,
    timestamps: timestamps,
    evidenceTimestamps: team?.evidenceTimestamps || {},
    startTime: earliestTime,
    completedAt: team?.completedAt || null,
    totalTimeMs: team?.totalTimeMs || null,
    solution: team?.solution || null,
    lastUpdate: now
};
    
        console.log(`💾 Saving unlock all for team ${teamName}`);
        await saveTeam(teamName, updatedTeam);
        await refreshTeams();
        
        console.log('✅ Unlock all complete');
    }
}

async function resetTeam(teamName) {
    if (confirm(`Reset πρόοδο για την ομάδα "${teamName}";`)) {
        const teams = await getAllTeams();
        const team = teams.find(t => t.name === teamName);
        
await saveTeam(teamName, {
    password: team?.password || null,
    teamSize: team?.teamSize !== undefined ? team.teamSize : null,
    unlocked: [],
    timestamps: {},
    startTime: null,
    completedAt: null,
    totalTimeMs: null
});
            refreshTeams();
        }
    }

async function deleteTeam(teamName) {
    if (confirm(`ΔΙΑΓΡΑΦΗ ΟΜΑΔΑΣ "${teamName}" ΚΑΙ ΟΛΩΝ ΤΩΝ ΣΥΝΔΕΔΕΜΕΝΩΝ ΕΡΕΥΝΩΝ;`)) {
        console.log(`🗑️ Starting deletion for team: ${teamName}`);
        localStorage.removeItem(`unlocked_teks_${teamName}`);
        console.log(`✅ Deleted from localStorage`);
        
        if (isFirebaseReady()) {
            try {
                const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
                const querySnapshot = await window.firebaseGetDocs(surveysRef);
                
                const deletePromises = [];
                let surveyCount = 0;
                
                querySnapshot.forEach((doc) => {
                    const docId = doc.id;
                    if (docId.startsWith(`${teamName}_pre_`) || docId.startsWith(`${teamName}_post_`)) {
                        console.log(`🗑️ Queuing survey for deletion: ${docId}`);
                        surveyCount++;
                        deletePromises.push(
                            window.firebaseDeleteDoc(
                                window.firebaseDoc(window.firebaseDB, 'surveys', docId)
                            ).then(() => {
                                console.log(`✅ Deleted survey: ${docId}`);
                            }).catch(err => {
                                console.error(`❌ Failed to delete survey ${docId}:`, err);
                            })
                        );
                    }
                });
                
                console.log(`📊 Found ${surveyCount} surveys to delete`);
                if (deletePromises.length > 0) {
                    await Promise.all(deletePromises);
                    console.log(`✅ All surveys deleted successfully`);
                }
                
                await window.firebaseDeleteDoc(
                    window.firebaseDoc(window.firebaseDB, 'teams', teamName)
                );
                console.log(`✅ Deleted team document: ${teamName}`);                
            } catch (error) {
                console.error('❌ Firebase delete error:', error);
                alert(`⚠️ Σφάλμα κατά τη διαγραφή: ${error.message}\nΕλέγξτε το console για λεπτομέρειες.`);
            }
        } else {
            console.warn('⚠️ Firebase not ready, only deleted from localStorage');
            alert('⚠️ Firebase δεν είναι διαθέσιμο. Διαγράφηκε μόνο τοπικά.');
        }
        
        refreshTeams();
    }
}

async function unlockAllForAll() {
    if (confirm('ΞΕΚΛΕΙΔΩΜΑ ΟΛΩΝ ΤΩΝ ΤΕΚΜΗΡΙΩΝ ΓΙΑ ΟΛΕΣ ΤΙΣ ΟΜΑΔΕΣ;')) {
        const teams = await getAllTeams();
        const allTeks = Array.from({length: TOTAL_TEKS}, (_, i) => (i + 1).toString());
        
        for (const team of teams) {
            const now = new Date().toISOString();
            const timestamps = {...(team.timestamps || {})};
            let earliestTime = team.startTime || now;
            
            allTeks.forEach((tek, i) => {
                if (!timestamps[tek]) {
                    timestamps[tek] = new Date(Date.now() + i * 100).toISOString();
                } else {
                    const existingTime = new Date(timestamps[tek]);
                    if (existingTime < new Date(earliestTime)) {
                        earliestTime = timestamps[tek];
                    }
                }
            });
            
await saveTeam(team.name, {
    password: team.password || null,
    teamSize: team.teamSize !== undefined ? team.teamSize : null,
    unlocked: allTeks,
    timestamps: timestamps,
    startTime: earliestTime,
    completedAt: team.completedAt || null,
    totalTimeMs: team.totalTimeMs || null,
    solution: team.solution || null,
    evidenceTimestamps: team.evidenceTimestamps || {}
});
        }
        refreshTeams();
    }
}

async function resetAll() {
    if (confirm('ΔΙΑΓΡΑΦΗ ΟΛΩΝ ΤΩΝ ΟΜΑΔΩΝ ΚΑΙ ΕΡΕΥΝΩΝ;')) {
        const teams = await getAllTeams();
        console.log(`🗑️ Resetting ${teams.length} teams...`);
        for (const team of teams) {
            localStorage.removeItem(`unlocked_teks_${team.name}`);
        }
        console.log(`✅ Deleted all from localStorage`);
        
        if (isFirebaseReady()) {
            try {
                for (const team of teams) {
                    await window.firebaseDeleteDoc(
                        window.firebaseDoc(window.firebaseDB, 'teams', team.name)
                    );
                    console.log(`✅ Deleted team: ${team.name}`);
                }
                
                const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
                const querySnapshot = await window.firebaseGetDocs(surveysRef);
                
                const deletePromises = [];
                let surveyCount = 0;
                
                querySnapshot.forEach((doc) => {
                    console.log(`🗑️ Deleting survey: ${doc.id}`);
                    surveyCount++;
                    deletePromises.push(
                        window.firebaseDeleteDoc(
                            window.firebaseDoc(window.firebaseDB, 'surveys', doc.id)
                        )
                    );
                });
                
                await Promise.all(deletePromises);
                
                console.log(`✅ Deleted ${teams.length} teams and ${surveyCount} surveys`);
            } catch (error) {
                console.error('❌ Firebase delete error:', error);
                alert(`⚠️ Σφάλμα: ${error.message}`);
            }
        }
        
        refreshTeams();
    }
}

    function generateUrls() {
        const output = document.getElementById('urlOutput');
        const urlList = document.getElementById('urlList');

        const urls = [];
        urls.push(`<strong>🎯 Team-Agnostic URLs (χρήστες πρέπει να είναι logged in):</strong><br><br>`);
        
        for (let i = 1; i <= TOTAL_TEKS; i++) {
            urls.push(`TEK ${i.toString().padStart(2, '0')}: ${BASE_URL}unlock_system.html?tek=${i}`);
        }

        urlList.innerHTML = urls.join('<br>');
        output.style.display = 'block';
    }

    function copyAllUrls() {
        const urlList = document.getElementById('urlList');
        const text = urlList.innerText;
        
        navigator.clipboard.writeText(text).then(() => {
            alert('✅ URLs αντιγράφηκαν στο clipboard!');
        });
    }

let firestoreUnsubscribe = null;
    let lastKnownTeamsState = {};
    
    function setupRealtimeListener() {
        if (!isFirebaseReady()) {
            console.warn('⚠️ Firebase not ready - using periodic refresh');
            setInterval(refreshTeams, 2000);
            return;
        }

        try {
            const teamsCollection = window.firebaseCollection(window.firebaseDB, 'teams');
            firestoreUnsubscribe = window.firebaseOnSnapshot(teamsCollection, 
                (snapshot) => {
                    console.log('🔥 Firebase real-time update received');
                    let hasChanges = false;
                    
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added' || change.type === 'modified') {
                            console.log(`📝 Team ${change.doc.id} was ${change.type}`);
                            hasChanges = true;
                        }
                        if (change.type === 'removed') {
                            console.log(`🗑️ Team ${change.doc.id} was removed`);
                            hasChanges = true;
                        }
                    });
                    
                    if (hasChanges) {
                        refreshTeams();
                    }
                },
                (error) => {
                    console.error('❌ Firebase listener error:', error);
                    setInterval(refreshTeams, 2000);
                }
            );
            console.log('✅ Real-time Firebase listener active');
            setInterval(async () => {
                const teams = await getAllTeams();
                const currentState = JSON.stringify(teams.map(t => ({
                    name: t.name,
                    unlocked: t.unlocked.length,
                    teamSize: t.teamSize,
                    completedAt: t.completedAt
                })));
                
                if (currentState !== lastKnownTeamsState) {
                    console.log('🔄 State change detected via polling');
                    lastKnownTeamsState = currentState;
                    refreshTeams();
                }
            }, 2000);
            
        } catch (error) {
            console.error('❌ Failed to setup Firebase listener:', error);
            setInterval(refreshTeams, 2000);
        }
    }
    
    window.addEventListener('storage', (e) => {
        if (e.key && e.key.startsWith('unlocked_teks_')) {
            console.log('💾 localStorage change detected from another tab');
            refreshTeams();
        }
    });

window.addEventListener('DOMContentLoaded', async () => {
        setTimeout(async () => {
            if (isFirebaseReady()) {
                showSyncStatus('✅ Connected - Real-time sync active', 'success');
            } else {
                console.warn('⚠️ Firebase not loaded - using localStorage only');
                showSyncStatus('⚠️ Local mode - No cloud sync', 'error');
            }
            
            await refreshTeams();
            setupRealtimeListener();
            await updateLeaderboardButton();
            setInterval(updateLeaderboardButton, 5000);
            setTimeout(() => {
                const status = document.getElementById('firebaseStatus');
                if (status && !status.classList.contains('syncing')) {
                    status.style.display = 'none';
                }
            }, 5000);
        }, 300);
    });

function showSyncStatus(message, type = 'success') {
        const status = document.getElementById('firebaseStatus');
        if (!status) return;
        
        status.classList.remove('syncing');
        
        if (type === 'syncing') {
            status.classList.add('syncing');
            status.style.background = '#17a2b8';
        } else if (type === 'success') {
            status.style.background = '#28a745';
        } else if (type === 'error') {
            status.style.background = '#dc3545';
        }
        
        status.innerHTML = message;
        status.style.display = 'block';
        
        if (type !== 'syncing') {
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
    }
    
async function checkLeaderboardStatus() {
    if (!window.firebaseDB) {
        console.warn('Firebase not ready');
        return false;
    }
    
    try {
        const docRef = window.firebaseDoc(window.firebaseDB, 'config', 'leaderboard');
        const docSnap = await window.firebaseGetDoc(docRef);
        
        if (docSnap.exists()) {
            return docSnap.data().unlocked || false;
        }
        return false;
    } catch (error) {
        console.error('Error checking leaderboard status:', error);
        return false;
    }
}

async function updateLeaderboardButton() {
    const isUnlocked = await checkLeaderboardStatus();
    const btn = document.getElementById('leaderboardToggleBtn');
    
    if (btn) {
        if (isUnlocked) {
            btn.innerHTML = '🔓 LEADERBOARD (ΟΜΑΔΕΣ)';
            btn.style.background = '#28a745';
        } else {
            btn.innerHTML = '🔒 LEADERBOARD (ΟΜΑΔΕΣ)';
            btn.style.background = '#dc3545';
        }
    }
}

async function toggleLeaderboard() {
    if (!window.firebaseDB) {
        alert('❌ Firebase δεν είναι διαθέσιμο!');
        return;
    }
    
    const currentStatus = await checkLeaderboardStatus();
    const newStatus = !currentStatus;
    
    try {
        const docRef = window.firebaseDoc(window.firebaseDB, 'config', 'leaderboard');
        await window.firebaseSetDoc(docRef, {
            unlocked: newStatus,
            lastModified: new Date().toISOString(),
            modifiedBy: 'admin'
        });
        
await updateLeaderboardButton();
        
    } catch (error) {
    
        console.error('Error toggling leaderboard:', error);
        alert('❌ Σφάλμα! Δοκιμάστε ξανά.');
    }
}

async function exportSurveyDataToExcel() {
    if (!window.firebaseDB) {
        alert('❌ Firebase not available!');
        return;
    }

    try {
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 10000; text-align: center;';
        statusDiv.innerHTML = '<div style="font-size: 48px; margin-bottom: 20px;">⏳</div><h3>Exporting Survey Data...</h3><p>Please wait...</p>';
        document.body.appendChild(statusDiv);

        const surveysRef = window.firebaseCollection(window.firebaseDB, 'surveys');
        const querySnapshot = await window.firebaseGetDocs(surveysRef);
        
        console.log(`📊 Found ${querySnapshot.size} survey responses`);

        if (querySnapshot.size === 0) {
            alert('No survey data found!');
            document.body.removeChild(statusDiv);
            return;
        }

        const allResponses = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            allResponses.push({
                docId: doc.id,
                ...data
            });
        });

        allResponses.sort((a, b) => {
            if (a.teamCode !== b.teamCode) {
                return (a.teamCode || '').localeCompare(b.teamCode || '', 'el');
            }
            if (a.memberName !== b.memberName) {
                return (a.memberName || '').localeCompare(b.memberName || '', 'el');
            }
            const typeOrder = { 'pre': 1, 'post': 2 };
            return (typeOrder[a.surveyType] || 3) - (typeOrder[b.surveyType] || 3);
        });

        const processedData = allResponses.map(survey => {
            const flatData = {
                'Document_ID': survey.docId || '',
                'Team_Code': survey.teamCode || '',
                'Member_Name': survey.memberName || '',
                'Survey_Type': survey.surveyType || '',
                'Submitted_At': survey.submittedAt || '',
                'Submission_Date': survey.submittedAt ? new Date(survey.submittedAt).toLocaleDateString('el-GR') : '',
                'Submission_Time': survey.submittedAt ? new Date(survey.submittedAt).toLocaleTimeString('el-GR') : '',
            };

            if (survey.responses) {
                Object.keys(survey.responses).forEach(key => {
                    const value = survey.responses[key];
                    if (Array.isArray(value)) {
                        flatData[key] = value.join('; ');
                    } else {
                        flatData[key] = value;
                    }
                });
            }

            return flatData;
        });

        const allHeaders = new Set();
        processedData.forEach(row => {
            Object.keys(row).forEach(key => allHeaders.add(key));
        });

        const metadataHeaders = ['Document_ID', 'Team_Code', 'Member_Name', 'Survey_Type', 'Submitted_At', 'Submission_Date', 'Submission_Time'];
        const otherHeaders = Array.from(allHeaders)
            .filter(h => !metadataHeaders.includes(h))
            .sort();
        const sortedHeaders = [...metadataHeaders, ...otherHeaders];
        const worksheetData = [
            sortedHeaders,
            ...processedData.map(row => 
                sortedHeaders.map(header => row[header] !== undefined ? row[header] : '')
            )
        ];

        const XLSX = await import('https://cdn.sheetjs.com/xlsx-0.20.1/package/xlsx.mjs');
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(worksheetData);
        const colWidths = sortedHeaders.map(header => {
            const maxLength = Math.max(
                header.length,
                ...processedData.map(row => 
                    String(row[header] || '').length
                ).slice(0, 100)
            );
            return { wch: Math.min(Math.max(maxLength + 2, 10), 50) };
        });
        ws['!cols'] = colWidths;

        XLSX.utils.book_append_sheet(wb, ws, 'Survey Responses');
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `Crime_Festival_2025_Survey_Data_${timestamp}.xlsx`;

        XLSX.writeFile(wb, filename, { 
            bookType: 'xlsx',
            type: 'binary',
            compression: true
        });

        document.body.removeChild(statusDiv);
        const successDiv = document.createElement('div');
        successDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 10000; text-align: center; max-width: 400px;';
        successDiv.innerHTML = `
            <div style="font-size: 64px; margin-bottom: 15px;">✅</div>
            <h3 style="margin-bottom: 10px;">Export Successful!</h3>
            <p style="margin-bottom: 15px;">Downloaded: <strong>${filename}</strong></p>
            <p style="font-size: 14px; opacity: 0.9;">Total responses: ${allResponses.length}</p>
            <p style="font-size: 14px; opacity: 0.9;">Pre-surveys: ${allResponses.filter(r => r.surveyType === 'pre').length} | Post-surveys: ${allResponses.filter(r => r.surveyType === 'post').length}</p>
        `;
        document.body.appendChild(successDiv);

        setTimeout(() => {
            document.body.removeChild(successDiv);
        }, 5000);

        console.log('✅ Export completed successfully');
        console.log(`📊 Statistics:
        - Total responses: ${allResponses.length}
        - Pre-surveys: ${allResponses.filter(r => r.surveyType === 'pre').length}
        - Post-surveys: ${allResponses.filter(r => r.surveyType === 'post').length}
        - Columns: ${sortedHeaders.length}
        `);

    } catch (error) {
        console.error('❌ Export error:', error);
        alert(`Export failed: ${error.message}\n\nCheck console for details.`);
        const statusDiv = document.querySelector('div[style*="position: fixed"]');
        if (statusDiv) {
            document.body.removeChild(statusDiv);
        }
    }
}

</script>
</body>
</html>